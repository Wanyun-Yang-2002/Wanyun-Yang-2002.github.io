<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog搭建过程(Hexo)</title>
    <url>/2021/12/14/Blog%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B(Hexo)/</url>
    <content><![CDATA[<p>一开始是按照网上搜索到的教程开始制作的，中途出了不少差错，于是便搁置了，直到今天才想起来。</p>
<h1 id="搭建教程"><a href="#搭建教程" class="headerlink" title="搭建教程"></a>搭建教程</h1><p>分享一个很实用的教程：<a href="http://www.wxylyw.com/2018/10/25/hexo%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%85%A8%E8%BF%87%E7%A8%8B/#more">hexo 从零搭建全过程</a><br>基本上如果没有什么其他问题的话一次性就搭建好了</p>
<h1 id="主题安装及美化"><a href="#主题安装及美化" class="headerlink" title="主题安装及美化"></a>主题安装及美化</h1><h2 id="基本安装及基础美化"><a href="#基本安装及基础美化" class="headerlink" title="基本安装及基础美化"></a>基本安装及基础美化</h2><p>关于主题页面设置的一些方法：<a href="https://haomingzhang.com/hexo_2/">hexo主题安装以及next8.0主题美化</a></p>
<h2 id="进阶美化参考"><a href="#进阶美化参考" class="headerlink" title="进阶美化参考"></a>进阶美化参考</h2><h3 id="包括了很多方面的美化，但对我而言用处并没有很大"><a href="#包括了很多方面的美化，但对我而言用处并没有很大" class="headerlink" title="包括了很多方面的美化，但对我而言用处并没有很大"></a>包括了很多方面的美化，但对我而言用处并没有很大</h3><p><a href="https://qianling.pw/hexo-optimization/">Hexo 优化汇总</a></p>
<h3 id="内容也比较丰富，有很多实用性强的美化"><a href="#内容也比较丰富，有很多实用性强的美化" class="headerlink" title="内容也比较丰富，有很多实用性强的美化"></a>内容也比较丰富，有很多实用性强的美化</h3><p><a href="https://vic.kim/2019/05/25/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%B9%8BNext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/">Hexo博客优化之Next主题美化</a><br><a href="https://blog.bill.moe/hexo-theme-next-config-optimization/">Hexo-NexT主题自定义配置高阶教程</a></p>
<h3 id="设置背景图片"><a href="#设置背景图片" class="headerlink" title="设置背景图片"></a>设置背景图片</h3><p>这个单拎出来推荐，是因为一开始搜了很多教程，但是尝试过之后都没有用，最终找到了这个教程，试了一次就成功了。<br><a href="https://www.cnblogs.com/cscshi/p/15196114.html">Hexo-NexT 设置博客背景图片</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang基础学习笔记</title>
    <url>/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><p>💡<a href="https://www.youtube.com/watch?v=yyUHQIec83I&t=72s">Golang Tutorial for Beginners | Full Go Course</a></p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ol>
<li><p>创建文件夹</p>
</li>
<li><p>创建main.go</p>
</li>
<li><p>执行命令，生成 go.mod 文件</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init 文件夹名</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 main.go 中输入如下代码，运行成功</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 注意：不使用的package不要import</p>
</li>
</ol>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>Discover mistakes at compile time, NOT at runtime</li>
</ol>
<h2 id="Variables-Constants"><a href="#Variables-Constants" class="headerlink" title="Variables &amp; Constants"></a>Variables &amp; Constants</h2><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><ol>
<li><p>变量的声明</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Go Conference&quot;</span></span><br><span class="line">name := <span class="string">&quot;Go Conference&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<ol>
<li>声明的变量必须使用，否则就不要声明变量</li>
</ol>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> conferenceName = <span class="string">&quot;Go Conference&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Welcome to&quot;</span>, conferenceName, <span class="string">&quot;booking application&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><p>与变量（Variables）类似，但值无法改变</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 const 声明</span></span><br><span class="line"><span class="keyword">const</span> conferenceTickets = <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h3 id="Package-Level-Variables"><a href="#Package-Level-Variables" class="headerlink" title="Package Level Variables"></a>Package Level Variables</h3><ul>
<li>Defined at the top <strong>outside of all functions  - 在main函数以外上面定义</strong></li>
<li>They can be <strong>accessed inside any of the functions</strong></li>
<li>And in all files, which are in the <strong>same package</strong></li>
<li>不能用 <code>:=</code> 创建</li>
<li>传参时不用写</li>
</ul>
<h3 id="Local-Variables"><a href="#Local-Variables" class="headerlink" title="Local Variables"></a>Local Variables</h3><ul>
<li>Defined <strong>inside a function or a block</strong></li>
<li>They can be <strong>accessed only inside that function or block of code</strong></li>
<li>Create the variable where you need it</li>
</ul>
<h2 id="Formatted-Output"><a href="#Formatted-Output" class="headerlink" title="Formatted Output"></a>Formatted Output</h2><p>Print formatted data</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;some text with a variable %s&quot;</span>, myVariable)</span><br></pre></td></tr></table></figure>

<h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><p>声明类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var something Type</span></span><br><span class="line"><span class="keyword">var</span> userName <span class="keyword">string</span></span><br></pre></td></tr></table></figure>

<p>检查类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 %T</span></span><br><span class="line">fmt.Printf(%T, something)</span><br></pre></td></tr></table></figure>

<ul>
<li>The type keyword creates a new type, with the name you specify</li>
<li>In fact, you could also create a type based on every other data type like int, string etc.</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Strings-Integers-Booleans"><a href="#Strings-Integers-Booleans" class="headerlink" title="Strings &amp; Integers &amp; Booleans"></a>Strings &amp; Integers &amp; Booleans</h3><ul>
<li><p>Strings : for <strong>textual data</strong>, defined with double quotes, eg : “This is a string”</p>
</li>
<li><p>Integers : representing <strong>whole numbers</strong>, positive and negative, eg : 5, 10, -20</p>
<p>  <img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.png" alt="01.png"></p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字42转字符串，依旧是十进制形式，若为16，则是16进制</span></span><br><span class="line">strconv.FormatUint(<span class="keyword">uint64</span>(<span class="number">42</span>), <span class="number">10</span>) <span class="comment">// 42, string</span></span><br><span class="line">strconv.FormatUint(<span class="keyword">uint64</span>(<span class="number">42</span>), <span class="number">16</span>) <span class="comment">// 2a, string</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Booleans : True or False</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> noSomething <span class="keyword">bool</span> = something == <span class="number">0</span></span><br><span class="line">noSomething := something == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><ul>
<li>Maps unique keys to values</li>
<li>You can retrieve the value by using its key later</li>
<li>All keys have the same data type</li>
<li>All values have the same data type</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[keyType]valueType)</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">var</span> userData = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">userData[<span class="string">&quot;firstName&quot;</span>] = firstName</span><br></pre></td></tr></table></figure>

<h3 id="Arrays-Slices"><a href="#Arrays-Slices" class="headerlink" title="Arrays &amp; Slices"></a>Arrays &amp; Slices</h3><ul>
<li><p>Arrays</p>
<ul>
<li>必须知道大小</li>
<li>Fixed Size</li>
<li>Only the <strong>same data type</strong> can be stored</li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bookings = [<span class="number">50</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bookings [<span class="number">50</span>]<span class="keyword">string</span></span><br><span class="line">bookings[<span class="number">0</span>] = <span class="string">&quot;Text&quot;</span></span><br><span class="line">bookings[<span class="number">1</span>] = first + <span class="string">&quot; &quot;</span> + last</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays的大小</span></span><br><span class="line"><span class="built_in">len</span>(array)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Slices</p>
<ul>
<li>大小可变</li>
<li>Slice is an abstraction of an Array</li>
<li>More flexible and powerful : <strong>variable-length</strong> or an sub-array of its own</li>
<li>Slices are also <strong>index-based</strong> and have a size, but is <strong>resized when needed</strong></li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明方式</span></span><br><span class="line"><span class="keyword">var</span> bookings []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">bookings := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">sliceName = <span class="built_in">append</span>(sliceName, elements)   <span class="comment">// Adds the element(s) at the end of the slice.</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Creating a slice with <code>make()</code></p>
<ul>
<li>Alternative way to create a slice</li>
<li>We need to define the initial size of the slice</li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bookings = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><ul>
<li>Collect different data types of data</li>
<li>type statement - Custom Types<ul>
<li>The <strong>type keyword creates a new type</strong>, with the name you specify</li>
<li><em>“create a type called “userData” <strong>based on a struct</strong> of firstName, lastName..”</em></li>
</ul>
</li>
<li>Defining a structure<ul>
<li>Mixed data type</li>
<li>Defining a structure (which fields) of the User Type</li>
</ul>
</li>
<li>It’s like a lightweight class, which e.g. doesn’t support inheritance</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建struct</span></span><br><span class="line"><span class="keyword">type</span> UserData <span class="keyword">struct</span> &#123;</span><br><span class="line">	firstName       <span class="keyword">string</span></span><br><span class="line">	numberOfTickets <span class="keyword">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">var</span> userData = UserData&#123;</span><br><span class="line">		firstName:       firstName,</span><br><span class="line">		numberOfTickets: userTickets,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">userData.firstName</span><br><span class="line">userData.numberOfTickets</span><br></pre></td></tr></table></figure>

<h2 id="User-Input"><a href="#User-Input" class="headerlink" title="User Input"></a>User Input</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Scan() 括号里要么是指针，要么是具体地址</span></span><br><span class="line">fmt.Scan(&amp;inputText)</span><br><span class="line">fmt.Scan(<span class="number">0xc00124</span>)</span><br></pre></td></tr></table></figure>

<p>user input validation</p>
<h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><ul>
<li>A pointer is a variable that <strong>points to the memory address of another variable.</strong></li>
<li>A special variable.</li>
</ul>
<p><img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Untitled.png" alt="Untitled"></p>
<h2 id="Scope-Rules"><a href="#Scope-Rules" class="headerlink" title="Scope Rules"></a>Scope Rules</h2><h3 id="Variable-Scopes"><a href="#Variable-Scopes" class="headerlink" title="Variable Scopes"></a>Variable Scopes</h3><p>Scope is the region of a program, where a defined variable can be accessed</p>
<p><strong>3 Levels of Scope</strong></p>
<ul>
<li>Local<ul>
<li>Declaration within function<ul>
<li>Can be used only within that function</li>
</ul>
</li>
<li>Declaration within block (eg. for, if-else)<ul>
<li>Can be used only within that block</li>
</ul>
</li>
</ul>
</li>
<li>Package<ul>
<li>Declaration outside all functions<ul>
<li>Can be used everywhere in the same package</li>
</ul>
</li>
</ul>
</li>
<li>Global<ul>
<li>Declaration outside all functions &amp; uppercase first letter<ul>
<li>Can be used everywhere across all packages</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><ul>
<li>Only have the “for loop”</li>
<li>Infinite Loop</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户使用 ctrl + C 退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质是</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>For-Each Loop : Iterating over a list</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Range iterates over elements for different data structures (so not only arrays and slices)</span></span><br><span class="line"><span class="comment">// For arrays and slices, range provides the index and value for each element</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历完bookings里面所有元素后结束循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, booking := <span class="keyword">range</span> bookings &#123;</span><br><span class="line">		<span class="keyword">var</span> names = strings.Fields(booking)</span><br><span class="line">		firstNames = <span class="built_in">append</span>(firstNames, names[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用不到index可以用下划线代替</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, booking := <span class="keyword">range</span> bookings &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>break</code>退出循环</li>
<li>使用<code>continue</code>继续</li>
</ul>
<h2 id="If-else-Switch"><a href="#If-else-Switch" class="headerlink" title="If-else &amp; Switch"></a>If-else &amp; Switch</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">		<span class="comment">// code to be executed if condition is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line">		<span class="comment">// code to be executed if condition is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// code to be executed if both conditions are false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以没有else, else if </span></span><br><span class="line"><span class="comment">// else if 可以有多个，else 只能有一个</span></span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>Allows a variable to be tested for equality against a list of values</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"></span><br><span class="line">text := <span class="string">&quot;B&quot;</span></span><br><span class="line"><span class="keyword">switch</span> text &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">				<span class="comment">// some code here</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">				<span class="comment">// some code here</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>:</span><br><span class="line">				<span class="comment">// same code here for C and D</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// some code here</span></span><br><span class="line">				<span class="comment">// Default handles the case, if no match is found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ul>
<li><strong>Encapsulate code</strong> into own container (&#x3D; function). Which <strong>logically belong together!</strong></li>
<li>Like variable name, you should give a function a <strong>descriptive name</strong></li>
<li><strong>Call the function by its name</strong>, whenever you want to execute this block of code</li>
<li>Every program has at least one function, which is the <strong>main()</strong> function</li>
<li>Function is only executed, when “called” !</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionName</span><span class="params">(parameters and parametersType)</span> <span class="params">(returnType)</span></span>&#123;</span><br><span class="line">		<span class="comment">// function body</span></span><br><span class="line">		<span class="comment">// Encapsulate code</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Function Parameters<ul>
<li>Information can be passed into functions as parameters</li>
<li>Parameters are also called arguments</li>
</ul>
</li>
<li>Returning values from a function<ul>
<li>A function can return data as a result</li>
<li>So a function can take an input and return an output</li>
<li>In Go you have to define the input and output parameters including its type explicitly</li>
<li>Returning multiple values</li>
</ul>
</li>
</ul>
<h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><ul>
<li><p>Go programs are organized into packages</p>
</li>
<li><p>A package is a <strong>collection of Go files</strong></p>
</li>
<li><p>如果全在一个package，运行时在包含所有go文件的文件夹终端输入<code>go run .</code></p>
<p>  <img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Untitled%201.png" alt="Untitled01"></p>
<p>  <img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Untitled%202.png" alt="Untitled02"></p>
<p>  <img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/jietu.png" alt="屏幕截图 2023-05-08 093352.png"></p>
</li>
</ul>
<h3 id="Multiple-Packages"><a href="#Multiple-Packages" class="headerlink" title="Multiple Packages"></a>Multiple Packages</h3><p><img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Untitled%203.png" alt="Untitled03"></p>
<h3 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h3><p><img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Untitled%204.png" alt="Untitled04"></p>
<p>module booking-app  &#x3D; import path</p>
<p>For all our packages in our booking-app application</p>
<h3 id="Import-package"><a href="#Import-package" class="headerlink" title="Import package"></a>Import package</h3><ul>
<li>Exporting a variable<ul>
<li>Make it available for all packages in the app</li>
<li><strong>Capitalize first letter - 首字母大写</strong></li>
</ul>
</li>
</ul>
<h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h2><ul>
<li><code>go …</code> starts a new goroutine &#x2F;&#x2F; 让它多进程同时运行(?)</li>
<li>A goroutine is a lightweight thread managed by the Go runtime</li>
<li>Waitgroup<ul>
<li>Waits for the lunched goroutine to finish</li>
<li>Package “sync” provides basic synchronization functionality</li>
<li><code>Add()</code> Sets the number of goroutine to wait for (increases the counter by the provided number)</li>
<li><code>Wait()</code> Blocks until the WaitGroup counter is 0</li>
<li><code>Done()</code> Decrements the WaitGroup counter by 1. So this is called by the goroutine to indicate that it’s finished</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">wg.Done()</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Untitled%205.png" alt="Untitled05"></p>
<ul>
<li>Managed by the go runtime, we are only interacting with these high level goroutines</li>
<li>Cheaper &amp; lightweight</li>
<li>You can run hundreds of thousands or millions goroutines without affecting the performance</li>
</ul>
<p><img src="/2023/05/13/Golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Untitled%206.png" alt="Untitled06"></p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>JS基础学习笔记</title>
    <url>/2021/12/26/JS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><b> 看的视频是<a href="https://study.163.com/course/courseLearn.htm?coursejsId=195001#/learn/video?lessonId=2004&courseId=195001">翁恺老师讲的Javascript</a>,视频不是很长，不过了解js基础足够了，想深入学还得看别的+多多练习<br></b></p>
<h1 id="一开始在代码中记的笔记"><a href="#一开始在代码中记的笔记" class="headerlink" title="一开始在代码中记的笔记:"></a>一开始在代码中记的笔记:</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS学习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;alert(&#x27;hi&#x27;)&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 网页打开出现hi的提示 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- alert产生对话框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(<span class="string">&quot;hello world!&lt;br/&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// document是浏览器的页面（称为对象）</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// .表示左边的做右边的动作</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// write表示“写”</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//hello 是字符串，放在&quot;&quot;里面</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//结尾要加分号</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> hello;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//一个名叫hello的变量</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//var 定义变量</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//JS中变量没有类型，赋给变量的值有类型</span></span></span><br><span class="line"><span class="javascript">            hello = <span class="string">&quot;hello&quot;</span>;    <span class="comment">//赋值</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(hello+<span class="string">&quot;&lt;br/&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> age = <span class="number">16</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ot = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(hello + age+<span class="string">&quot;&lt;br/&gt;&quot;</span>);    <span class="comment">//对于字符串“+”就是字符串连接，输出hello16</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//加减乘除取模，比较大小，++--什么的都和C差不多</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//JS中数字不区分整数浮点数啥的，但是内部有范围</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> age1 = <span class="number">20</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> age2 = <span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(age1 &lt;= age2+<span class="string">&quot;&lt;br/&gt;&quot;</span>);   <span class="comment">//输出true</span></span></span><br><span class="line"><span class="javascript">            </span></span><br><span class="line"><span class="javascript">            <span class="comment">//判断语句</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//if-else语句</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">//建议在if和else后面永远放一对&#123;&#125;，可以保证不犯错误</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (age &gt; <span class="number">18</span>)&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;成年啦&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;还小呢&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;好啦好啦知道辣&quot;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="comment">//switch-case语句</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> t = <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">switch</span> (t) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">1</span>:</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;你好&quot;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">case</span> <span class="number">2</span>:</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;早&quot;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">default</span>:    <span class="comment">//默认</span></span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;WTF???&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span></span><br><span class="line"><span class="javascript">            o.name = <span class="string">&quot;John&quot;</span>;</span></span><br><span class="line"><span class="javascript">            o.age = <span class="number">30</span>;</span></span><br><span class="line"><span class="javascript">            o.salary = <span class="number">300</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> o)&#123;</span></span><br><span class="line"><span class="javascript">                alert(x);</span></span><br><span class="line"><span class="javascript">                alert(x + <span class="string">&quot;=&quot;</span> + o[x]);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (confirm(<span class="string">&quot;还继续吗？&quot;</span>))&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;继续&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;再见&quot;</span>);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> name = prompt(<span class="string">&quot;你的名字是： &quot;</span>);</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;hello&quot;</span>+name);</span></span><br><span class="line"><span class="javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="JavaScript介绍-后面用markdown做的笔记"><a href="#JavaScript介绍-后面用markdown做的笔记" class="headerlink" title="JavaScript介绍(后面用markdown做的笔记)"></a>JavaScript介绍(后面用markdown做的笔记)</h1><ul>
<li>是一种可以在浏览器中运行的脚本语言</li>
<li>主要用来实现在浏览器端的动作<ul>
<li>用户交互</li>
<li>数据处理</li>
</ul>
</li>
<li>JavaScript是解释性语言</li>
<li>HTML中的js<ul>
<li>在head中定义函数<ul>
<li>&lt;script languang &#x3D; “JavaScript”&gt;</li>
</ul>
</li>
<li>在相应标记中定义动作<ul>
<li>&lt;onXXX&#x3D;””&gt;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="变量和计算"><a href="#变量和计算" class="headerlink" title="变量和计算"></a>变量和计算</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>用于存放数据的东西</li>
<li>var：用于定义变量</li>
</ul>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><ul>
<li>if-else语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建议在if和else后面永远放一对&#123;&#125;，可以保证不犯错误</span></span><br><span class="line">  <span class="keyword">if</span> (age &gt; <span class="number">18</span>)&#123;</span><br><span class="line">      alert(<span class="string">&quot;成年啦&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">      alert(<span class="string">&quot;还小呢&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  alert(<span class="string">&quot;好啦好啦知道辣&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>switch-case语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (t) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        alert(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        alert(<span class="string">&quot;早&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:    <span class="comment">//默认</span></span><br><span class="line">        alert(<span class="string">&quot;WTF???&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>逻辑计算<ul>
<li>and：&amp;&amp;</li>
<li>or：||</li>
<li>not：!</li>
</ul>
</li>
<li>优先级<ul>
<li>所有的逻辑运算符的优先级都低于关系运算符</li>
<li>! &gt; &amp;&amp; &gt; ||</li>
</ul>
</li>
<li>条件运算符（三元运算符）<ul>
<li>格式：&lt;exp&gt;?&lt;v1&gt;:&lt;v2&gt;</li>
<li>解释：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (exp)&#123;</span><br><span class="line">    v1;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul>
<li>while语句<ul>
<li>while语句让同一段代码可以重复执行很多次<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先判断再循环</span></span><br><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> LIMIT = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt;= LIMIT)&#123;</span><br><span class="line">    alert(count);</span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>do-while语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环一次之后才开始判断</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>();</span><br></pre></td></tr></table></figure></li>
<li>for语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i=i+<span class="number">1</span>)&#123;</span><br><span class="line">    alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>函数就是一段代码，我们给它起个名字，放起来，以后可以用</li>
<li>JavaScript有很多内置函数，能帮助我们实现很多有用的功能</li>
<li>定义函数<ul>
<li>function fun_name(){}</li>
<li>var f &#x3D; new Function(“x”,”y”,”return x*y”); 等价于 function f(x,y){return x*y;}</li>
<li>其他的和其他语言都差不多的样子…</li>
</ul>
</li>
<li>变量空间<ul>
<li>定义在函数外的变量在整个页面中都有效</li>
<li>定义在函数内部的变量只在函数内有效</li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul>
<li>var marks &#x3D; new Array(); 创建一个数组marks</li>
<li>marks[0] ：[]可以访问数组，数组从0开始</li>
<li>数组长度：marks.length给出数组marks的长度<ul>
<li>.length可写</li>
</ul>
</li>
<li>堆栈操作<ul>
<li>.push</li>
<li>.pop</li>
</ul>
</li>
<li>队列操作<ul>
<li>.push</li>
<li>.shift</li>
</ul>
</li>
<li>排序操作<ul>
<li>.sort</li>
<li>.reverse    按顺序颠倒</li>
</ul>
</li>
<li>其他操作<ul>
<li>.concat 连接</li>
<li>.slice 取出某一部分作为新数组</li>
<li>.splice(开始位置，删除个数，插入元素)</li>
</ul>
</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><ul>
<li>对象是JavaScript的一种复合数据类型，它可以把多个数据集中在一个变量中，并且给其中的每个数据起名字</li>
<li>或者说，对象是一个属性集合，每个属性有自己的名字和值<ul>
<li>JavaScript并不像其他OOP语言那样有类的概念，不是先设计类再制造对象</li>
</ul>
</li>
<li>创建对象<ul>
<li>var o &#x3D; new Object();</li>
<li>var ciclr &#x3D; {x:0,y:0,radius:2};</li>
</ul>
</li>
<li>访问对象属性<ul>
<li>.运算符</li>
</ul>
</li>
<li>删除对象属性<ul>
<li>delete book.chapter1;</li>
</ul>
</li>
<li>遍历所有属性<ul>
<li>for (var x in o)…<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">o.age = <span class="number">30</span>;</span><br><span class="line">o.salary = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> o)&#123;</span><br><span class="line">  alert(x);</span><br><span class="line">  alert(x + <span class="string">&quot;=&quot;</span> + o[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="浏览器里的JavaScript"><a href="#浏览器里的JavaScript" class="headerlink" title="浏览器里的JavaScript"></a>浏览器里的JavaScript</h1><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><ul>
<li>浏览器的全局对象是window</li>
<li>所有全局的变量实际上是window的成员<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var answer = 12;</span><br><span class="line">alert(window.answer);</span><br></pre></td></tr></table></figure></li>
<li>window.document表示浏览器窗口中的HTML页面</li>
<li>document.write()将内容写入页面</li>
<li>页面中的元素就是document里的成员</li>
<li>HTML中的JavaScript<ul>
<li>在&lt;script&gt;&lt;&#x2F;script&gt;标记中</li>
<li>在&lt;script&gt;的src属性或archive指定的外部文件中<ul>
<li>&lt;script src &#x3D; “”&gt;&lt;&#x2F;script&gt;</li>
<li>一个纯粹的代码文件，没有HTML标记</li>
</ul>
</li>
<li>在某个HTML标记的事件处理器中<ul>
<li>&lt;p onMouseOver &#x3D; “”&gt;   鼠标移动到上面时</li>
<li>body事件<ul>
<li>onLoad 页面显示之前</li>
<li>onUnload 页面关掉之前</li>
</ul>
</li>
</ul>
</li>
<li>简单对话框<ul>
<li>alert</li>
<li>confirm</li>
<li>prompt</li>
</ul>
</li>
<li>状态栏（在页面最下面（左下角？））<ul>
<li>status &#x3D; </li>
<li>defaultStatus &#x3D;</li>
</ul>
</li>
<li>定时器<ul>
<li>setInterval()</li>
</ul>
</li>
</ul>
</li>
<li>window的控制方法<ul>
<li>window.open()</li>
<li>windoe.close()</li>
</ul>
</li>
<li>location对象<ul>
<li>window.location代表当前文档的URL</li>
</ul>
</li>
</ul>
<h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><ul>
<li>document的成员<ul>
<li>anchors[]</li>
<li>forms[]</li>
<li>images[]</li>
<li>cookie</li>
<li>title</li>
<li>bgColor</li>
<li>fgColor</li>
<li>linkColor</li>
<li>alinkColor</li>
<li>vlinkColor</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的深拷贝与浅拷贝</title>
    <url>/2024/07/18/Python%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<ul>
<li>浅拷贝：复制对象，但不复制包含的子对象。修改复制后的子对象会影响原始对象。</li>
<li>深拷贝：递归地复制对象及其包含的所有子对象。复制后的对象与原始对象完全独立。</li>
</ul>
<p><strong>可变对象 vs 不可变对象</strong></p>
<ul>
<li>不可变对象：如整数、字符串、元组等，不能修改它们的内容。对它们的重新赋值只会改变引用，不会影响原对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">b = a</span><br><span class="line">b = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: 3</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出: 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可变对象：如列表、字典、集合等，可以修改它们的内容。多个引用指向同一个可变对象时，对该对象的任何修改都会反映到所有引用中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>对于不可变对象，重新赋值会创建一个新的对象引用，不会影响原对象。<br>对于可变对象，修改对象内容会影响所有引用，因为它们指向的是同一个对象。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2024/07/22/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h1><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-str">题目: 28. 找出字符串中第一个匹配项的下标</a><br>自己写了几版代码，总是有几个样例无法通过，于是去看了题解。</p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP算法这个名字来源于Knuth，Morris和Pratt三个人的首字母。<br>上面提到的leetcode28题是KMP算法经典题目，KMP的经典思想是：当出现字符串不匹配时，可以记录⼀部分之前已经匹配的⽂本内容，利⽤这些信息避免从头再去做匹配。<br>KMP算法主要应用于字符串匹配问题，它的重点在于前缀表。</p>
<h1 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h1><p>前缀表是⽤来回退的，它记录了模式串与主串(⽂本串)不匹配的时候，模式串应该从哪⾥开始重新匹配。<br>前缀表中记录的是：下标i之前（包括i）的字符串中，有多⼤⻓度的相同前缀后缀。</p>
<h2 id="最长公共前后缀"><a href="#最长公共前后缀" class="headerlink" title="最长公共前后缀"></a>最长公共前后缀</h2><ul>
<li>前缀：包含首字符，不包含尾字符的所有子串</li>
<li>后缀：包含尾字符，不包含首字符的所有子串</li>
</ul>
<p>前缀表内容：{前缀 : 最长相等前后缀}<br>例如：aabaaf</p>
<table>
<thead>
<tr>
<th>下标i之前</th>
<th>最长公共前后缀</th>
<th>最长公共前后缀长度</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>aa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td></td>
<td>0</td>
</tr>
</tbody></table>
<p>最终的前缀表：</p>
<table>
<thead>
<tr>
<th>下标i</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>a</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
<td>f</td>
</tr>
<tr>
<td>最长公共前后缀</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>下标i并不一定是字符串的最后一个字符</strong><br>当匹配到下标i对应的字符时，如果不匹配，则依据下标i-1的最长公共前后缀的数值，把下标移动到下标数值的位置继续进行匹配。</p>
<blockquote>
<p>当匹配到<code>下标5</code>对应的字符<code>f</code>时，如果不匹配，则依据<code>下标4</code>(字符<code>a</code>)的最长公共前后缀的数值<code>2</code>，把下标移动到<code>下标2</code>的位置(字符<code>b</code>)继续进行匹配。</p>
</blockquote>
<p>很绕，需要拿笔多画几遍才能理解。<br>真神奇，原本觉得这样根本达不到最终结果，可是换不同的字符串匹配，模拟了好几遍，居然最后都能得到正确答案。<br><strong>如果用这种前缀表，要注意当回退到下标0(<code>next[j] &lt; 1</code>)时，要将文本串向后移一位。</strong> 如果是前缀表统一减一的前缀表，则是当<code>next[j] &lt; 0</code>时，将文本串向后移一位再继续匹配。</p>
<h2 id="如何求前缀表？"><a href="#如何求前缀表？" class="headerlink" title="如何求前缀表？"></a>如何求前缀表？</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">定义函数 getNext(<span class="keyword">next</span>, s) &#123;</span><br><span class="line">  <span class="regexp">//</span> 初始化</span><br><span class="line">  <span class="regexp">//</span> 处理前后缀不相同的情况</span><br><span class="line">  <span class="regexp">//</span> 处理前后缀相同的情况</span><br><span class="line">  <span class="regexp">//</span> 更新<span class="keyword">next</span>的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i：指向后缀末尾<br>j：指向前缀末尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是前缀表统一减一，那么初始化<code>j = -1</code>，while循环时，判断条件是<code>j &gt;= 0</code>，比较的是<code>s[j-1]</code>，其它的对应进行修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params"><span class="built_in">next</span>, s</span>):</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">next</span>[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>，<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:</span><br><span class="line">            j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>[i] = j</span><br></pre></td></tr></table></figure>
<h1 id="KMP算法完整代码"><a href="#KMP算法完整代码" class="headerlink" title="KMP算法完整代码"></a>KMP算法完整代码</h1><p><strong>c++版是copy的，python版的是自己写的</strong></p>
<h2 id="普通前缀表"><a href="#普通前缀表" class="headerlink" title="普通前缀表"></a>普通前缀表</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span>[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>[i] = j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(needle)</span><br><span class="line">        self.getNext(<span class="built_in">next</span>, needle)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):    <span class="comment"># 最后一次相等之后还有j+=1，所以判断的时候必须是 j == len(needle)</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>自己定义的函数如果写在<code>class Solution</code>里面，就得写成<code>def getNext(self, next, s):</code>，调用的时候要写成<code>self.getNext(next, needle)</code><br>如果定义的函数写在外面，就直接写<code>def getNext(next, s):</code>，直接调用<code>getNext(next, needle)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params"><span class="built_in">next</span>, s</span>):</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="built_in">next</span>[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:</span><br><span class="line">            j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>[i] = j</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(needle)</span><br><span class="line">        getNext(<span class="built_in">next</span>, needle)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = <span class="built_in">next</span>[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):    <span class="comment"># 最后一次相等之后还有j+=1，所以判断的时候必须是 j == len(needle)</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="前缀表统一减一"><a href="#前缀表统一减一" class="headerlink" title="前缀表统一减一"></a>前缀表统一减一</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span>* next, <span class="keyword">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">                j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(needle.size())</span></span>;</span><br><span class="line">		<span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>], needle);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组里记录的起始位置为-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">                j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">                j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">                <span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNext</span>(<span class="params">self, <span class="built_in">next</span>, s</span>):</span></span><br><span class="line">        j = -<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span>[<span class="number">0</span>] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j + <span class="number">1</span>]:</span><br><span class="line">                j = <span class="built_in">next</span>[j]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j + <span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>[i] = j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span>] * <span class="built_in">len</span>(needle)</span><br><span class="line">        self.getNext(<span class="built_in">next</span>, needle)</span><br><span class="line">        j = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j + <span class="number">1</span>]:</span><br><span class="line">                j = <span class="built_in">next</span>[j]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j + <span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(needle) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i - j</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种题就和二叉树那种题一样，应该多练多做，做熟练了就好了。理解很重要，理解了之后就算一时半会写不出来代码，多耗一会自己模拟几遍，代码也能写出来。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客使用方法</title>
    <url>/2022/05/04/hexo%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天想给博客里加内容的时候，完全忘记了要怎么做，所以赶紧搜了一下怎么增加、上传文章，顺便给自己做了一个教程。</p>
<h3 id="在博客根目录打开命令行"><a href="#在博客根目录打开命令行" class="headerlink" title="在博客根目录打开命令行"></a>在博客根目录打开命令行</h3><p>可以用cmd也可以用git bash（个人感觉这个方便一点）</p>
<h3 id="新增文章"><a href="#新增文章" class="headerlink" title="新增文章"></a>新增文章</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type"></span>文章标题</span><br></pre></td></tr></table></figure>
<h3 id="编辑文章"><a href="#编辑文章" class="headerlink" title="编辑文章"></a>编辑文章</h3><p>在sourse&#x2F;_posts中找到生成的md文件，打开后就可以写文章了</p>
<h3 id="生成文章"><a href="#生成文章" class="headerlink" title="生成文章"></a>生成文章</h3><p>先清理旧的数据</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br></pre></td></tr></table></figure>
<p>生成新的页面</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure>
<h3 id="预览生成的页面"><a href="#预览生成的页面" class="headerlink" title="预览生成的页面"></a>预览生成的页面</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>
<p>预览结束后关闭预览输入<code>ctrl+c</code>就可以了</p>
<h3 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
<p>如果不想预览想直接生成并发布的话，也可以直接用</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">hexo g <span class="meta">&amp;&amp; hexo d</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python链表</title>
    <url>/2024/07/23/Python%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>从学c语言的时候就对链表很恐惧，现在跟着做题倒也能做，画图也能画，但是写代码的时候还是会害怕会心虚，所以想把链表的样子彻底搞懂。<br>假设有一个链表是<br><code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None</code><br>那么在Python中打印它的头节点会得到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ListNode&#123;val: <span class="number">1</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">2</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">3</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">4</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">5</span>, <span class="built_in">next</span>: <span class="literal">None</span>&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>把这个结果的格式修改一下，看起来就像是一环套一环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ListNode&#123;</span><br><span class="line">  val: <span class="number">1</span>, <span class="built_in">next</span>: ListNode&#123;</span><br><span class="line">    val: <span class="number">2</span>, <span class="built_in">next</span>: ListNode&#123;</span><br><span class="line">      val: <span class="number">3</span>, <span class="built_in">next</span>: ListNode&#123;</span><br><span class="line">        val: <span class="number">4</span>, <span class="built_in">next</span>: ListNode&#123;</span><br><span class="line">          val: <span class="number">5</span>, <span class="built_in">next</span>: <span class="literal">None</span>&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>用cur表示当前节点，从头节点开始向后：<br>这样看起来就像剥洋葱一样，一层一层的嵌套着，直到达到最后一个节点，只剩下None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cur.val = 1</span></span><br><span class="line">ListNode&#123;val: <span class="number">1</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">2</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">3</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">4</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">5</span>, <span class="built_in">next</span>: <span class="literal">None</span>&#125;&#125;&#125;&#125;&#125;</span><br><span class="line"><span class="comment"># cur.val = 2</span></span><br><span class="line">ListNode&#123;val: <span class="number">2</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">3</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">4</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">5</span>, <span class="built_in">next</span>: <span class="literal">None</span>&#125;&#125;&#125;&#125;</span><br><span class="line"><span class="comment"># cur.val = 3</span></span><br><span class="line">ListNode&#123;val: <span class="number">3</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">4</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">5</span>, <span class="built_in">next</span>: <span class="literal">None</span>&#125;&#125;&#125;</span><br><span class="line"><span class="comment"># cur.val = 4</span></span><br><span class="line">ListNode&#123;val: <span class="number">4</span>, <span class="built_in">next</span>: ListNode&#123;val: <span class="number">5</span>, <span class="built_in">next</span>: <span class="literal">None</span>&#125;&#125;</span><br><span class="line"><span class="comment"># cur.val = 5 </span></span><br><span class="line">ListNode&#123;val: <span class="number">5</span>, <span class="built_in">next</span>: <span class="literal">None</span>&#125;</span><br><span class="line"><span class="comment"># cur 到最后</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>如果<code>cur</code>节点的样子是<code>ListNode&#123;val: 3, next: ListNode&#123;val: 4, next: ListNode&#123;val: 5, next: None&#125;&#125;&#125;</code>，那么<code>cur.next</code>的节点就是:<code>ListNode&#123;val: 4, next: ListNode&#123;val: 5, next: None&#125;&#125;</code>。等到遍历到最后一个节点，就只剩一个<code>None</code>了。</p>
<p>同理，如果<code>cur.val == 1</code>，那么<code>cur.next.val == 2</code></p>
<p>依据以上的结果，就可以将它们对应起来：</p>
<table>
<thead>
<tr>
<th>节点&#x2F;链表</th>
<th><code>1</code></th>
<th><code>-&gt;</code></th>
<th><code>2</code></th>
<th><code>-&gt;</code></th>
<th><code>3</code></th>
<th><code>-&gt;</code></th>
<th><code>4</code></th>
<th><code>-&gt;</code></th>
<th><code>5</code></th>
<th><code>-&gt;</code></th>
<th><code>None</code></th>
</tr>
</thead>
<tbody><tr>
<td>节点1</td>
<td>.val</td>
<td>.next</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>节点2</td>
<td></td>
<td></td>
<td>.val</td>
<td>.next</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>节点3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>.val</td>
<td>.next</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>节点4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>.val</td>
<td>.next</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>节点5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>.val</td>
<td>.next</td>
<td></td>
</tr>
</tbody></table>
<p>（这样看更直观一点？）</p>
<ul>
<li><code>当前节点.next</code>就是指向后面的所有的箭头，<code>当前节点.next.val</code>就是指向后面的第一个的节点的值。</li>
<li><code>节点5.next.val</code>不存在，在运行代码会报错<code>AttributeError: &#39;NoneType&#39; object has no attribute &#39;val&#39;</code>。</li>
<li><code>节点5.next</code>指向的是<code>None</code>，所以<code>while</code>循环遍历链表的时候，都是<code>while cur:</code>，如果为<code>None</code>就说明到最后了。</li>
<li>创建虚拟头节点<code>dumpy = ListNode(next=head)</code>，就是在<code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None</code>前面再加一个<code>0</code>，就变成了<code>0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; None</code></li>
<li>假设要删掉<code>节点4</code>，那当<code>cur</code>走到<code>节点3</code>时，进行<code>cur.next = cur.next.next</code>操作，就成功删掉了<code>节点4</code></li>
</ul>
<p>差不多就这样，后面如果再遇到问题再补充。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>《焦虑是一种能量》</title>
    <url>/2024/07/22/%E3%80%8A%E7%84%A6%E8%99%91%E6%98%AF%E4%B8%80%E7%A7%8D%E8%83%BD%E9%87%8F%E3%80%8B/</url>
    <content><![CDATA[<p>书名：焦虑是一种能量<br>作者：尹依依</p>
<hr>
<p>让焦虑消失，对成年人来说，简直是一个不可能完成的任务。无论你多么佛系，生活总有办法将你打趴在地。既然一定会焦虑，我们不妨多思考一下怎么利用焦虑的力量。</p>
<hr>
<p>当我们焦虑的时候，一味地告诉自己不要担心，有时候反而会更糟糕。心理学里有个词汇，叫二级焦虑，就是担心自己太焦虑而引发的更大的焦虑。</p>
<hr>
<p>朱莉·诺勒姆教授有一套关于<strong>防御性悲观主义倾向的测试题</strong>，大家可以用来思考自己化解焦虑的方式。</p>
<ul>
<li>在开始某项任务时，总是预计最坏结果。</li>
<li>会经常想，事情一定会变得更糟。</li>
<li>会尝试从各个角度去思考可能有的最糟糕结果。</li>
<li>会担心不能达成目标或者完成任务。</li>
<li>会花很多时间担心事情会出错的环节。</li>
<li>会想象如果任务失败了，自己受伤和挫败的情绪。</li>
<li>会思考应对失误的各种可能方法。</li>
<li>会经常提醒自己不要松懈，不要太过自信。</li>
<li>会花很多的时间来计划所有环节。</li>
<li>会经常担心失误，所以准备也会更充分。</li>
</ul>
<p>如果你对以上问题的回答大多数是“Yes”，那你就有可能拥有将焦虑化作动力的能力，好好利用起来吧！<br>人生路上，如果焦虑无法避免，那么不妨就从焦虑中寻找动力。小说家G.B.斯特恩说过：“乐观的人发明飞机探索天空，悲观的人发明降落伞防止坠落。”如果我们懂得怎样看待情绪，那么每种情绪都有力量。</p>
<hr>
<p>我们的文化推崇喜怒不形于色、泰山崩于前而色不变，所以我们习惯偷着乐、躲着哭。斯坦福大学心理学副教授珍妮·蔡是一名专门研究东亚文化的心理学专家，她曾经对比中国和美国的少儿图书，发现中国儿童读物的人物表情明显更内敛，少有大笑或者大哭等张力十足的表情。在研究中她还指出：情绪相对来说是一个更加西方化的概念，而将情绪细分，并不是每一种文化与生俱来的意识。这个观点我完全同意。相比把情绪挂在嘴边的西方人来说，我们要弄清楚自己的内心感受是个大难题。英国的幼儿园常会挂着情绪图谱，上面有愤怒、悲哀、愉快、害怕等情绪，孩子们从小就被教育去感受情绪。相比之下，中国的成年人很少能准确地感知自己的情绪。</p>
<hr>
<p>为什么处处要求完美会带来焦虑？要回答这个问题，我们需要剖析“完美”这个词，看清楚完美主义的真相。在心理学上，<strong>完美主义有六大倾向：对自己要求高；觉得别人对自己的期待高；觉得如果不做得完美，就会被批评或者导致灾难、不利的后果；不停怀疑自我；严格遵循次序；不能接受错误</strong>。完美主义的这些倾向在不同个体身上会表现出不同的症状。		</p>
<blockquote>
<p>六大倾向前四个都占了，后两个没明白什么意思不确定</p>
</blockquote>
<p>我究竟为什么需要完美？如果是为了得到“观众”的喝彩和“裁判”的评判，那么，那些观众和裁判对我来说真的重要吗？如果是为了将一件事情做好，那么，是不是只要自己尽力了就可以了？</p>
<blockquote>
<p>别太在意别人的看法，即使别人是什么权威，也不要畏惧，不要害怕ta对你的看法、ta对你的评判。</p>
</blockquote>
<hr>
<p>美国社会心理学家亚伯拉罕·马斯洛，提出了人类需求五层次理论。他曾经在研究里描述过缺乏安全感的表现：<br>把世界看成是充满野兽的丛林，危险无处不在；内心深信其他人都自私而且目的不纯，所以宁愿孤身一人也不与人同行；不愿意信任别人，富有攻击性；经常陷入强烈的焦虑和紧张状态，看待事物悲观，很难获得愉悦感；总被内疚折磨，时常拷问内心；大多有点神经质、行事自私以及以自我为中心。</p>
<hr>
<p>治愈心理创伤是非常艰难的。但是，如果不去关注曾经的伤痛，后果可能会更严重。过往激起的小水花经过时间的酝酿，也许会变为惊天巨浪，将现在的我们吞噬。<br>第一次诊疗中，她痛哭着对我说，她觉得自己的人生没有希望了。我递了一张纸巾给她，然后轻轻告诉她：<strong>“可是，你活了下来。你做得很好。”</strong></p>
<ol>
<li>在情绪稳定的状态下处理创伤。人在情绪的冲击下很难理性地思考问题，所以首先要确保自己的情绪是足够稳定的，然后再开始疗伤。我常在接待来访者之前通过深呼吸来平静自己的情绪。</li>
<li>打捞回忆。从过往的千般思绪里，筛出那些最痛苦的记忆。如果有很多伤害，不要急着一起记起，安抚内心是需要耐心和时间的。</li>
<li>识别当初受到伤害时的情绪。当时的感受是羞愧、害怕、耻辱，还是愤怒？弄清楚了之后才能对症下药。</li>
<li>承认那些感受的正当性，原谅自己当初的不作为。过去的事情也许现在看来不算什么，但对当时的自己来说是很严重的，所以成了心结。<strong>有一点是确定的，当时的自己已经尽力了。</strong></li>
</ol>
<blockquote>
<p>我已经做出了当时能做的最好的选择，我已经尽力了，那些糟糕事情的发生不是我的过错。</p>
</blockquote>
<p>治疗创伤后遗症最艰难的步骤是重现创伤史，也就是要营造一个安全的环境，让患者反复面对曾经被伤害的自己，一步步在心理上脱敏。这个环节很痛苦，用痛如剔骨来形容也不过分。正如我的女患者，多次崩溃发怒，提起那些伤害，就好像一次次撕开还未愈合的伤口。</p>
<hr>
<p>你也许会想，<strong>这么痛苦的新生，宁愿不要好吗！确实是啊，但是你不要，生活也不会放过你啊</strong>。未来会发生的可能不至于是丧子失亲，但是被分手、被开除、被退租、被拒绝、被打压、被霸凌、被忽视等，都很常见。<strong>与其期待无风无浪的人生，还不如主动强身健体。将不可避免的苦难变成滋养，是没有办法中最好的办法</strong>。在短暂又漫长的这一生里，困难处处可见，创伤也不会轻易放过我们。心理上是否有弹性，决定了我们是不是能够在困境中依然保持希望，保持乐观，保持冷静思考。这种抗挫能力可以在创伤之后被激发，也可以从现在就开始培养。</p>
<p>最后强调一点，创伤激发性成长理论的奠基者、美国北卡罗来纳大学心理学教授Tedeschi曾经说过，<strong>女性更容易从创伤中获得成长</strong>，这也是我在心理咨询中反复验证过的。柔软的力量在这里也可以看到呢。用我们自己的爱和温暖来支撑自己的开放性和主动性，就一定能成长。“任何不能杀死你的，都会使你更强大。”</p>
<blockquote>
<p>女人，当之无愧的第一性。</p>
</blockquote>
<hr>
<p><strong>能接受自己的错误，才可以继续勇敢前行</strong>。反之，则会在心理上停步不前。是让犯错的痛苦将我们吞没，还是拍拍身上的灰，爬起来继续往前走？这是一个艰难的抉择，抉择的权利掌握在你手里。</p>
<hr>
<p>那些明白自己负面情绪来源的人，相比对负面情绪一无所知的人，情绪控制力高30%。了解自己情绪的人，相对来说也有着更健康的心理防御水平，不会酒精、毒品上瘾，很少对别人乱发脾气，能够对自己的情绪负责，也更能够与身边的人共情。</p>
<p>情绪是我们行动的发动机。每一种情绪，背后都带着推动我们前行的力量。身未动，心已远，就是代表着情绪能够比身体更早地对周围的环境产生反应。比如害怕，会让我们在险恶的环境下随时应战或者逃跑；悲哀，会提醒我们需要疗伤和宣泄；愤怒，则会让我们更有力量来保护自己。如果我们没有这些“负面”情绪的保护，我们会失去边界，我们会任人欺负，我们会罔顾危险，我们会让心里的伤口加重，导致出现更严重的心理障碍。</p>
<p>我们之所以害怕负面情绪，一个很大的原因是我们觉得自己不能控制这些负面情绪。<strong>负面情绪不是洪水猛兽，用围堵打压的方式去消灭是不会奏效的。只有耐心地聆听它们，它们才能平息</strong>。</p>
<hr>
<p>自怜会让我们不停地和别人比较。<strong>比较，是很多糟糕情绪的直接起因</strong>。我的来访者看到了别人的快乐，却忘了那只是生活的一面而已。孩子带来的不仅仅是欢笑，还有尿片、无休止的哭闹、自由的丧失和沉重的责任。而拥有伴侣更不等于快乐，一段感情的维持需要双方极大的妥协，中间还可能夹杂着无数冲突。所以，<strong>与其羡慕、嫉妒别人的生活，不如过好自己的生活</strong>。</p>
<blockquote>
<p>与其羡慕别人一毕业就找到大厂生活月入一两万，不如过好自己的生活…她月入一两万可她也加班到很晚…<br>可这是否有种精神胜利法的感觉呢？</p>
<blockquote>
<p>确实，“与其羡慕别人，不如过好自己的生活”这种观点有时会被误认为是一种精神胜利法，即通过贬低别人的成就或者生活质量来安慰自己。然而，这种想法的核心并不是要贬低别人，而是要<strong>把关注点放在自己身上，找到自己的价值和满足感</strong>。<br>精神胜利法通常是指一种自我安慰的方式，通过心理上的自我欺骗来让自己感觉更好，而没有实际的行动或改进。但这里提到的观点其实是在倡导一种健康的心理状态和生活态度，即专注于自己能控制和改善的方面，而不是浪费精力在比较和嫉妒上。<br>这种态度的好处在于：</p>
<ol>
<li>减少负面情绪：<strong>不断地与别人比较很容易产生嫉妒、不满和焦虑情绪，而专注于自己的生活和进步可以减少这些负面情绪</strong>。</li>
<li>提升自我价值感：每个人的生活都有独特的挑战和成就，<strong>学会欣赏自己的努力和成果可以提升自我价值感</strong>。</li>
<li>培养积极的生活态度：通过专注于自己的成长和幸福，可以培养更积极和主动的生活态度，而不是被动地羡慕和嫉妒别人。</li>
<li>实际行动的推动力：把注意力集中在自己的生活上，可以更清楚地认识到自己的目标和需要，从而采取实际行动去改善和提升自己的生活。</li>
</ol>
<p>当然，这并不意味着不能从别人的成功中得到启发和动力。关键在于心态的调整：<strong>不是通过贬低别人的成就来安慰自己，而是通过欣赏自己的独特之处和努力，找到属于自己的幸福和满足感</strong>。<br>总结来说，与其说是精神胜利法，不如说是一种<strong>积极的生活哲学</strong>，它强调的是<strong>自我认同和实际行动</strong>，而不是通过心理上的自我欺骗来获得短暂的安慰。</p>
</blockquote>
</blockquote>
<hr>
<p>自爱，从心理学的角度来说，就是尊重、接受和原谅自己。<br>你的努力、你的优秀、你的坚持需要被尊重；你的尝试、你的妥协、你的难堪需要被接受；你的痛苦、你的放弃、你的失败需要被原谅。<br>在生活中，<strong>你就是自己最好的朋友，你需要聆听自己、善待自己、照顾自己</strong>，而不是等着别人来聆听、善待和照顾你。</p>
<p>自爱是一个非常大的话题，也是我们人生中必修的功课。下面这些小贴士，可以让你开始自爱的旅程:</p>
<ol>
<li>我们要<strong>停止和外界比较</strong>。马上，立即！我们从别人身上，永远不会找到自己的光芒。</li>
<li><strong>放大你努力的过程</strong>，而不是努力的结果。还记得那次朗诵比赛你没有得奖，但是你努力克服了害羞走上台前的感受吗？对的，不要太在意结果，但是努力享受跨越障碍的过程，这才是最终跑起来的动力。</li>
<li>学着<strong>面对真实的自己</strong>，从外在到内心。可以是素颜一天，也可以是写下自己内心脆弱的想法，然后说我可以，一时半会儿做不到，也没有关系。真实的你，就是最美丽的。</li>
</ol>
<hr>
<p>如何不被内疚感折磨？<br>如果是被他人情感绑架时产生了内疚情绪，我们要怎么办呢？</p>
<p>情感隔离和设立边界是最行之有效的方法。没有底线地去满足他人的期望，只会造成对方更多地索取，还会失去自己成长的力气和空间。意识到自己的情感和行为被控制时，请务必立即止损，哪怕他们是“为你好”，<strong>哪怕他们是你目前还不敢与之对抗的人，你也要在心中划清与他们的界限，然后在适当的时候选择离开和切割</strong>。总会有机会的，只要你想。<br>忠于自己，永远是最难的，在任何时候都难。但是不是因为难，我们就不去做呢？这也许更值得思考，毕竟人生是自己的，不是吗？</p>
<blockquote>
<p>总有机会的。</p>
</blockquote>
<hr>
<blockquote>
<p>后面的章节内容都是关于婚姻、孩子的话题，作为一个不打算结婚也不打算生娃的人，这些话题和我并没有什么关系，就不看了。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>《硅谷是个什么谷》</title>
    <url>/2024/08/08/%E3%80%8A%E7%A1%85%E8%B0%B7%E6%98%AF%E4%B8%AA%E4%BB%80%E4%B9%88%E8%B0%B7%E3%80%8B/</url>
    <content><![CDATA[<p>书名：硅谷是个什么谷<br>作者：虎皮妈</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>《硅谷是个什么谷》写的是从07年到17年的故事，准确一点的话，最后结尾的部分也简略写到了19年。<br>六个主要角色贯穿全文，着重描写的程悦欣算是女主吧。<br>程悦欣一开始的个性不是很讨喜，至少我不喜欢，等看到后面的时候，才渐渐品出了这个角色身上吸引人的地方。</p>
<blockquote>
<p>“其实跟你现在做的事情差不多，”林锐忽然说，“你不是喜欢当售票员，你是喜欢跟人打交道，做协调工作。怪不得你会那么热衷政治。”</p>
</blockquote>
<p>直到看到这里，我才恍然意识到，人都是复杂的，如果从另一个角度看，程悦欣身上也有很多可取的点。</p>
<h1 id="句评"><a href="#句评" class="headerlink" title="句评"></a>句评</h1><p>以前玩和平精英，一直不知道“大吉大利今晚吃鸡”这句话是哪来的，原来是从这句英语传来的：</p>
<blockquote>
<p>winner winner chicken dinner</p>
</blockquote>
<hr>
<p>作者写到金融危机那一年时，看到书里的郑懿在美国找工作看得我想哭（虽然行业不同）</p>
<blockquote>
<p>郑懿的时间全部被排满了。下课跑各个教授办公室，混个脸熟然后套磁看能否替她引荐谁；报名各个律师协会的各种活动，社交假笑哈哈哈，手边随时带着一份简历；手机通讯录翻了又翻，从前收的名片找了又找，雪花般的E-mail发出去，开头都是客气的寒暄“好久不联系，最近怎么样”，最后都是巧妙的提问：“有些职业发展上的问题，可不可以出来喝杯咖啡聊一聊？”脚不沾地，在家的时间越来越少</p>
</blockquote>
<hr>
<p>虽然我没去过美国，更没在美国留过学，但看到林锐为了在opt到期前找到工作，也有种感同身受的绝望。</p>
<blockquote>
<p>从找工作谈到经济形势再谈到朋友近况，这顿午饭一直吃到下午两点，这时林锐才恋恋不舍地往回开。回去，就是回到睁眼闭眼刷题写代码的日子，回到对着日历数自己还剩多少时间可以合法留在美国的日子，回到越来越没自信能拿钱砸郑懿的日子。</p>
</blockquote>
<p>这下真是同行业了，可惜我bg不如林锐，最近刷题写代码也有些力不从心(T_T)<br>不知何时才能找到工作</p>
<hr>
<p>看程悦欣从刚到美国看到游行队伍又怂又害怕，到七年后举着标语参加游行活动，有点感动。<br>原来她高中时也参与过，人选择的路、会做的事冥冥之中是注定的</p>
<blockquote>
<p>那是程悦欣刚到美国的第二天，在伯克利校园里，纤细的她在人群里好奇而恐惧地看着眼前经过的游行队伍。张思禹让她去向别人要传单，她说，我不敢，你去。</p>
</blockquote>
<blockquote>
<p>安安很好奇，扭头看着程悦欣，妈妈的脸上有一种令他不熟悉的表情。于是他更安静了。大家都很喜欢这个镜头，一个推车里的小孩和他背后的标语，于是每隔几分钟，都有人上来给安安拍照。咔嚓咔嚓，安安更觉得，或许自己很重要，不哭不闹，瞪大眼睛，一张小脸颇为严肃。</p>
<p>湾区本地电视台和报纸报道游行时，不约而同都用了程悦欣一手推安安，一手举标语的镜头。</p>
<p>照片上程悦欣背后的人山人海被虚化了，她整个人肌肉紧绷，一手推车，一手高举标语，嘴里正大声疾呼，整个人有一种一往无前的力量感。</p>
</blockquote>
<blockquote>
<p>程悦欣的父母对所有的社会活动都特别警惕，资本主义国家的社会运动也不行。高中时程悦欣跟着去抗议北约轰炸中国驻南斯拉夫大使馆，就被逮回来一顿臭骂。</p>
</blockquote>
<hr>
<p>同样的道理放在郝会会身上也是一样的，冥冥之中她们过去的经历在影响着她们未来的生活</p>
<blockquote>
<p>郝会会说：“你不给我弄好散伙就散伙！”想想窝火，转头对老罗再骂回去：“我去你妈的。”<br>旁边两个小工看得目瞪口呆，鼓掌：“郝姐，现在厉害啊！”<br>听完程悦欣抱怨，郝会会对着红绿灯发了会儿呆。<br>小时候，她觉得村里的女人都粗俗，村头村尾都喧嚣，为一点家长里短一哭二闹三上吊，不是悍妇就是泼妇。郝会会不喜欢，她喜欢镇上学校里说话轻声慢气的女老师，她喜欢斯斯文文架副眼镜的男老师。媒人给她介绍胡金柱，她看一眼，就觉得喜欢。那是博士啊。<br>跟博士结婚那十来年，郝会会永远赔笑脸，轻声细语，有委屈也往肚子里咽。哪怕离婚了，胡金柱也要感慨，郝会会是个贤惠媳妇。如果胡金柱现在再遇到自己呢？郝会会想想要发笑，胡金柱能认识叉着腰指着老罗鼻子骂的泼妇吗？他如果看到，恐怕不会后悔自己离婚了吧。郝会会有些伤感，活了半辈子，活成了自己小时候最不想成为的人。</p>
</blockquote>
<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>其实今天看了两本书，先看了L分享给我的《回国33天》，看到小红书评论区有人推荐《硅谷是个什么谷》，看完第一本之后就直接又看了第二本。<br>《回国33天》写的也还行，有种看剧情片的感觉，故事写的很有生活感也很drama。<br>但是很明显，《硅谷是个什么谷》写的更好，比《回国33天》好多了。</p>
<p>《硅谷是个什么谷》里，每个人都有血有肉的，每个人的选择都和性格、过去的经历联系在一起，冥冥之中他们都过上了意料之外情理之中的生活（其实并不那么意料之外）。写的真的好真实，看的过程仿佛真的和他们一起经历了那些事情一样，像是他们身边的某个不起眼的朋友，虽然没在文中出现，但切切实实的见证了他们这么多年的生活。</p>
<h1 id="角色点评（不分先后顺序）"><a href="#角色点评（不分先后顺序）" class="headerlink" title="角色点评（不分先后顺序）"></a>角色点评（不分先后顺序）</h1><h2 id="郑懿"><a href="#郑懿" class="headerlink" title="郑懿"></a>郑懿</h2><p>小说里其实更喜欢郑懿这个大女主一般的角色，原生家庭糟糕，却能一步步闯出来，为自己律所合伙人的目标而努力奋斗，且不会为了男人停留。<br>但太拼了，后来得了乳腺癌，手术成功，希望她在平行世界里生活得越来越好。</p>
<h2 id="冷敏"><a href="#冷敏" class="headerlink" title="冷敏"></a>冷敏</h2><p>冷敏在文中也是一个很强大的女角色，但对她的描写太少了，不喜欢这种过于冷漠过于不近人情过于不择手段的人。<br>是，为了上司的赏识抢功劳、盗用化用同事辛苦做好的PPT，确实有胆有谋，不想承认但是某种程度上这种人就是更容易混得好。<br>独自创业，拉人入伙，在cto退出时不近人情的让他签下竞业协议，让他放弃股权。在国内创业出现问题时，利用自己孩子哭声逼迫员工高强度加班；裁掉一路跟着走来的鹏哥（实话，对这个角色没啥印象）；后面又毫不手软裁掉员工。<br>作为一个员工，不择手段往上爬，没毛病。<br>作为一个老板，创业红火的时候没亏待员工，这点没话说；在创业寒冬时，为了减小成本，裁员似乎也没问题。<br>人很复杂，看待角度不同，感受也不同。<br>我还是不太喜欢这个角色。</p>
<h2 id="林锐"><a href="#林锐" class="headerlink" title="林锐"></a>林锐</h2><p>这个角色，就像作者在后记里说的那样，写的太理想化了。现实中恐怕没有这样的男人。<br>近朱者赤近墨者黑，我不信他没有受到胡金柱的影响，更何况他后来回国创业，花花世界迷人眼，真有人能一直把握住底线吗？我不信。<br>不做点评了。</p>
<h2 id="郝会会"><a href="#郝会会" class="headerlink" title="郝会会"></a>郝会会</h2><p>一开始，确实怒其不争。<br>但是每个人的人生经历不同，她能做的也是她能想到的最好的解决办法。<br>虽然人蠢，但愿意听周围人的建议，踏实肯干。没有在离婚后只顾自怨自艾，而是听取了建议，为自己而活，逐渐将日子过得好了起来。</p>
<h2 id="程悦欣"><a href="#程悦欣" class="headerlink" title="程悦欣"></a>程悦欣</h2><p>打眼一看，这是个娇妻角色。一句“我养你”就被骗到了美国，和张思禹住在合租房里。不愿意学英语、不愿意考gre，梦想就是找个好老公养着自己。<br>嗯，确实找了个好老公。如果忽略张思禹精神出轨+差点肉体出轨的话。<br>好在后来终于自立自强起来，重新念了大学（也得亏她周围有郝会会和郑懿，有俩能参照的榜样，能让她意识到要自强），找到了热爱的事业。<br>感情丰富、娇生惯养长大，这确实让程悦欣有些做作，但这同样让她富有同情心。<br>她和郑懿、郝会会，有着截然不同的成长经历，却成为了很好的朋友。这三个人的友谊能够保持这么多年，我认为程悦欣起到了很大的作用。<br>本性不坏，单纯可爱。</p>
<h2 id="张思禹"><a href="#张思禹" class="headerlink" title="张思禹"></a>张思禹</h2><p>好吧，整本书看下来，能做到张思禹这个程度的男的恐怕也是超过了80%的♂。<br>会反思自己，会承担家务，会说到做到（还真做到了养程悦欣）。<br>可这又怎样呢，还是对冷敏动心了。一开始因为同事间的竞争还恨冷敏，结果呢？冷敏解释几句，故作心动一下，张思禹就精神出轨了。喝酒喝多了，和冷敏亲了，如果不是突然想到程悦欣，恐怕半推半就的就做了。<br>能否忍受一个对你很好但是精神出轨的♂？<br>反正这问题和我无关。</p>
<h2 id="胡金柱"><a href="#胡金柱" class="headerlink" title="胡金柱"></a>胡金柱</h2><p>整本书最让人恶心的人。<br>抛妻弃子、回国当教授后勾引学生（还不止一个）<br>恶心！他的父母也恶心！恶心的父母养出了恶心的胡金柱。</p>
<h2 id="冯品芝"><a href="#冯品芝" class="headerlink" title="冯品芝"></a>冯品芝</h2><p>老移民，20世纪偷渡来的美国。<br>一开始六个人就租住在冯品芝的房子里。<br>是个本性不坏的老太太。<br>会给郝会会、程悦欣出主意，会给郝会会25万刀的启动资金，会帮忙照顾郝会会的孩子……<br>挺善良的。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2024/08/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>回溯法也叫回溯搜索法，是一种搜索的方式。<br>回溯是递归的副产品，只要有递归就会有回溯。</p>
<p>就像是，递归到最底之后还要返回上一级，回溯就是返回的过程。<br>比如1-&gt;2-&gt;3，递归看完1，看完2，看完3之后，要返回到2的位置，返回的过程就相当于回溯的过程。</p>
<h2 id="回溯法的效率："><a href="#回溯法的效率：" class="headerlink" title="回溯法的效率："></a>回溯法的效率：</h2><p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，所以回溯法并不是什么高效的算法。</p>
<h2 id="回溯法能解决的问题："><a href="#回溯法能解决的问题：" class="headerlink" title="回溯法能解决的问题："></a>回溯法能解决的问题：</h2><ol>
<li>组合问题：N个数里面按一定规则找出k个数的集合<br>组合是不强调元素顺序的，排列是强调元素顺序。组合无序，排列有序。<ul>
<li><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></li>
<li><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17.电话号码的字母组合</a></li>
<li><a href="https://leetcode.cn/problems/combination-sum/">39.组合总和</a></li>
<li><a href="https://leetcode.cn/problems/combination-sum-ii/">40.组合总和II</a></li>
<li><a href="https://leetcode.cn/problems/combination-sum-iii/">216.组合总和III</a></li>
</ul>
</li>
<li>切割问题：一个字符串按一定规则有几种切割方式<ul>
<li><a href="https://leetcode.cn/problems/palindrome-partitioning/">131.分割回文串</a></li>
<li><a href="https://leetcode.cn/problems/restore-ip-addresses/">93.复原IP地址</a></li>
</ul>
</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集<ul>
<li><a href="https://leetcode.cn/problems/subsets/">78.子集</a></li>
<li><a href="https://leetcode.cn/problems/subsets-ii/">90.子集II</a></li>
</ul>
</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式<ul>
<li><a href="https://leetcode.cn/problems/permutations/">46.全排列</a></li>
<li><a href="https://leetcode.cn/problems/permutations-ii/">47.全排列II</a></li>
</ul>
</li>
<li>棋盘问题：N皇后，解数独等等<ul>
<li><a href="https://leetcode.cn/problems/n-queens/">51.N皇后</a></li>
<li><a href="https://leetcode.cn/problems/sudoku-solver/">37.解数独</a></li>
</ul>
</li>
<li>其他问题<ul>
<li><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491.递增子序列</a></li>
<li><a href="https://leetcode.cn/problems/reconstruct-itinerary/">332.重新安排行程</a></li>
</ul>
</li>
</ol>
<h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h2><p>回溯法解决的都是在集合中递归查找子集，所以都可以抽象为树形结构。集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。<br>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）<br><img src="/2024/08/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/backtracking.png" alt="backtracking.png"></p>
<h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><ol>
<li>回溯函数模板返回值以及参数<br>函数返回值一般为void<br>无法一次性确定参数。先写逻辑，需要什么参数，添加什么参数</li>
<li>回溯函数终止条件<br>搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</li>
<li>回溯搜索的遍历过程<br>for循环（横向遍历）遍历集合区间，一个节点有多少个孩子，这个for循环就执行多少次。<br>backtracking（递归）（纵向遍历）这里自己调用自己，实现递归。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
整体的伪代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/08/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="代码随想录-Day19-二叉树"><a href="#代码随想录-Day19-二叉树" class="headerlink" title="代码随想录 - Day19 - 二叉树"></a>代码随想录 - Day19 - 二叉树</h1><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。<br>满二叉树除了满足普通二叉树的性质，还具有以下性质：</p>
<ul>
<li>满二叉树中第 i 层的节点数为 2^(n-1)^ 个。</li>
<li>深度为 k 的满二叉树必有 2^k^-1 个节点 ，叶子数为 2^(k-1)^。</li>
<li>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。</li>
<li>具有 n 个节点的满二叉树的深度为 log<del>2</del>(n+1)。</li>
</ul>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~2^(h-1)^ 个节点。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>前面介绍的满二叉树和完全二叉树都没有数值，而二叉搜索树是有数值的，是一个有序树。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：<br>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<h2 id="题目分类"><a href="#题目分类" class="headerlink" title="题目分类"></a>题目分类</h2><h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h3><p>二叉树主要有两种遍历方式：</p>
<ul>
<li>深度优先遍历DFS：先往深走，遇到叶子节点再往回走。</li>
<li>广度优先遍历BFS：一层一层的去遍历。<br><b>这两种遍历是图论中最基本的两种遍历方式</b><br>从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</li>
<li>深度优先遍历<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，前中后序指的就是中间节点的位置就可以了。<br>中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<p>深度优先搜索主要使用递归的方式实现，也可以借助栈使用非递归的方式实现。<br>广度优先搜索一般使用队列来实现。</p>
<h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a><strong>二叉树的递归遍历</strong></h4><p>递归算法的三个要素</p>
<ol>
<li><strong>确定递归函数的参数和返回值</strong>： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件</strong>： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑</strong>： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<h5 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        left = self.preorderTraversal(root.left)</span><br><span class="line">        right = self.preorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [root.val] + left + right</span><br></pre></td></tr></table></figure>
<br>

<h5 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        left = self.inorderTraversal(root.left)</span><br><span class="line">        right = self.inorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left + [root.val] + right</span><br></pre></td></tr></table></figure>
<br>

<h5 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        left = self.postorderTraversal(root.left)</span><br><span class="line">        right = self.postorderTraversal(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left + right + [root.val]</span><br></pre></td></tr></table></figure>
<br>

<h4 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a><strong>二叉树的迭代遍历</strong></h4><h5 id="144-二叉树的前序遍历-1"><a href="#144-二叉树的前序遍历-1" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 中结点先处理</span></span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="comment"># 右孩子先入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            <span class="comment"># 左孩子后入栈</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h5 id="94-二叉树的中序遍历-1"><a href="#94-二叉树的中序遍历-1" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur = root</span><br><span class="line">        stack = []                      <span class="comment"># 不能提前将root结点加入stack中</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:                     <span class="comment"># 先迭代访问最底层的左子树结点</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 到达最左结点后处理栈顶结点 </span></span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right         <span class="comment"># 取栈顶元素右结点</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h5 id="145-二叉树的后序遍历-1"><a href="#145-二叉树的后序遍历-1" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:                        <span class="comment"># 以 中右左 的顺序遍历</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)            <span class="comment"># 中结点先处理</span></span><br><span class="line">            <span class="keyword">if</span> node.left:                   <span class="comment"># 左孩子入栈</span></span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:                  <span class="comment"># 右孩子入栈</span></span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res[: :-<span class="number">1</span>]                   <span class="comment"># 返回反转之后的结果，反转后即为 左右中的顺序</span></span><br></pre></td></tr></table></figure>
<br>
前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。
这是因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！
<br>

<h4 id="二叉树的统一迭代法"><a href="#二叉树的统一迭代法" class="headerlink" title="二叉树的统一迭代法"></a><strong>二叉树的统一迭代法</strong></h4><p>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</p>
<p>如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。</p>
<h5 id="144-二叉树的前序遍历-2"><a href="#144-二叉树的前序遍历-2" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">                </span><br><span class="line">                stack.append(node)</span><br><span class="line">                stack.append(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                res.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h5 id="94-二叉树的中序遍历-2"><a href="#94-二叉树的中序遍历-2" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()          <span class="comment"># 更新节点</span></span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right:          <span class="comment"># 添加右节点（空节点不入栈）</span></span><br><span class="line">                    stack.append(node.right)</span><br><span class="line"></span><br><span class="line">                stack.append(node)      <span class="comment"># 添加中节点   </span></span><br><span class="line">                stack.append(<span class="literal">None</span>)      <span class="comment"># 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left:           <span class="comment"># 添加左节点（空节点不入栈）</span></span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:                       <span class="comment"># 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                node = stack.pop()      <span class="comment"># 重新取出栈中元素</span></span><br><span class="line">                res.append(node.val)    <span class="comment"># 加入到结果集</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h5 id="145-二叉树的后序遍历-2"><a href="#145-二叉树的后序遍历-2" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                stack.append(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    stack.append(node.right)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    stack.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = stack.pop()</span><br><span class="line">                res.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的属性"><a href="#二叉树的属性" class="headerlink" title="二叉树的属性"></a>二叉树的属性</h3><h3 id="二叉树的修改与构造"><a href="#二叉树的修改与构造" class="headerlink" title="二叉树的修改与构造"></a>二叉树的修改与构造</h3><h3 id="求二叉搜索树的属性"><a href="#求二叉搜索树的属性" class="headerlink" title="求二叉搜索树的属性"></a>求二叉搜索树的属性</h3><h3 id="二叉树公共祖先问题"><a href="#二叉树公共祖先问题" class="headerlink" title="二叉树公共祖先问题"></a>二叉树公共祖先问题</h3><h3 id="二叉搜索树的修改与构造"><a href="#二叉搜索树的修改与构造" class="headerlink" title="二叉搜索树的修改与构造"></a>二叉搜索树的修改与构造</h3><h2 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h2><p>二叉树可以链式存储，也可以顺序存储。<br>那么链式存储方式就用指针， 顺序存储的方式就是用数组。<br>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。<br>用数组来存储二叉树如何遍历的呢？<br><b>如果父节点的数组下标是<code>i</code>，那么它的左孩子就是 <code>i * 2 + 1</code>，右孩子就是 <code>i * 2 + 2</code>。</b><br>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br></pre></td></tr></table></figure>


<h1 id="代码随想录-Day20-二叉树"><a href="#代码随想录-Day20-二叉树" class="headerlink" title="代码随想录 - Day20 - 二叉树"></a>代码随想录 - Day20 - 二叉树</h1><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h2><p>用队列来做这道题，思路不难</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:            <span class="comment"># 二叉树为空</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            result.append(level)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<br>

<h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h2><p>和上一题思路一致，最后返回倒过来的结果就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<br>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>注意在本题中，不能直接在<code>if</code>判断中用<code>len(queue)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> i == size - <span class="number">1</span>:</span><br><span class="line">                    res.append(node.val)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h2><p>基础层序遍历，加上平均值的计算就好了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = <span class="number">0</span></span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level += cur.val</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            res.append(level / cnt)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> cur.children:</span><br><span class="line">                    queue.append(child)</span><br><span class="line">            res.append(level)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h2 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515. 在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></h2><p>基础层序遍历+找每个<code>level</code>的最大值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestValues</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            level = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            level.sort(key=<span class="literal">None</span>, reverse=<span class="literal">True</span>)</span><br><span class="line">            res.append(level[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br>

<h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2><p>原本所有的都指向<code>NULL</code>，所以不用管指向<code>NULL</code>的，只需要把不该指向<code>NULL</code>的改到它本该指向的节点就行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;<span class="type">Optional</span>[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.<span class="built_in">next</span> = cur</span><br><span class="line">                prev = cur</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>

<h2 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h2><p>和上一题一模一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.<span class="built_in">next</span> = cur</span><br><span class="line">                prev = cur</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><p>看一共有多少层就完了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<br>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2><p>注意一下<code>cnt += 1</code>的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    <span class="keyword">return</span> cnt</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<br>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做层序遍历的时候没有看递归法，只看了基础的模板<br>层序遍历比较好理解，多敲一敲，手熟了就写的快了<br>相关题目基本是在原代码基础上修改即可做出来</p>
<h1 id="代码随想录-Day21-翻转二叉树"><a href="#代码随想录-Day21-翻转二叉树" class="headerlink" title="代码随想录 - Day21 - 翻转二叉树"></a>代码随想录 - Day21 - 翻转二叉树</h1><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><p>翻转二叉树的题目用前序遍历、后序遍历、层序遍历都可以做，但递归的中序遍历不能用（使用递归的中序遍历，某些节点的左右孩子会翻转两次）。</p>
<ul>
<li>递归法（前序遍历）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
迭代法：前序遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
递归法：中序遍历<br>两次<code>self.invertTree(root.left)</code>避免节点左右孩子翻转两次<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
迭代法：中序遍历<br>两次<code>if node.left: stack.append(node.left)</code>避免节点左右孩子翻转两次</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>递归法：后序遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>迭代法：后序遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append(node.right)</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>针对二叉树的问题，解题之前一定要想清楚究竟是前中后序遍历，还是层序遍历。</p>
<p>二叉树解题的大忌就是自己稀里糊涂的过了，但不知道自己是怎么遍历的。</p>
<h1 id="代码随想录-Day22-对称二叉树"><a href="#代码随想录-Day22-对称二叉树" class="headerlink" title="代码随想录 - Day22 - 对称二叉树"></a>代码随想录 - Day22 - 对称二叉树</h1><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><p>递归法：</p>
<ol>
<li><p>确定递归函数的参数和返回值<br> 要比较的是根节点下的两个子树，比较参数为左右子树的节点，返回值为True或False</p>
</li>
<li><p>确定终止条件<br>遇到不相等时终止；全部比较完后终止<br>比较是否相同：</p>
<ul>
<li>节点为空的情况<ul>
<li>左节点为空，右节点不为空，不对称，return false</li>
<li>左不为空，右为空，不对称 return false</li>
<li>左右都为空，对称，返回true</li>
</ul>
</li>
<li>节点不为空的情况<ul>
<li>左右都不为空，比较节点数值，不相同就return false</li>
</ul>
</li>
</ul>
</li>
<li><p>确定单层递归的逻辑<br>单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left, root.right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        <span class="comment">#首先排除空节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment">#排除了空节点，再排除数值不相同的情况</span></span><br><span class="line">        <span class="keyword">elif</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#此时就是：左右节点都不为空，且数值相同的情况</span></span><br><span class="line">        <span class="comment">#此时才做递归，做下一层的判断</span></span><br><span class="line">        outside = self.compare(left.left, right.right) <span class="comment">#左子树：左、 右子树：右</span></span><br><span class="line">        inside = self.compare(left.right, right.left) <span class="comment">#左子树：右、 右子树：左</span></span><br><span class="line">        isSame = outside <span class="keyword">and</span> inside <span class="comment">#左子树：中、 右子树：中 （逻辑处理）</span></span><br><span class="line">        <span class="keyword">return</span> isSame</span><br></pre></td></tr></table></figure>
<p>迭代法：</p>
<ol>
<li>用队列<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root.left) <span class="comment">#将左子树头结点加入队列</span></span><br><span class="line">        queue.append(root.right) <span class="comment">#将右子树头结点加入队列</span></span><br><span class="line">        <span class="keyword">while</span> queue: <span class="comment">#接下来就要判断这这两个树是否相互翻转</span></span><br><span class="line">            leftNode = queue.popleft()</span><br><span class="line">            rightNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode: <span class="comment">#左节点为空、右节点为空，此时说明是对称的</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#左右一个节点不为空，或者都不为空但数值不相同，返回false</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            queue.append(leftNode.left) <span class="comment">#加入左节点左孩子</span></span><br><span class="line">            queue.append(rightNode.right) <span class="comment">#加入右节点右孩子</span></span><br><span class="line">            queue.append(leftNode.right) <span class="comment">#加入左节点右孩子</span></span><br><span class="line">            queue.append(rightNode.left) <span class="comment">#加入右节点左孩子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
<li>用栈<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        st = [] <span class="comment">#这里改成了栈</span></span><br><span class="line">        st.append(root.left)</span><br><span class="line">        st.append(root.right)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            rightNode = st.pop()</span><br><span class="line">            leftNode = st.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">or</span> <span class="keyword">not</span> rightNode <span class="keyword">or</span> leftNode.val != rightNode.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            st.append(leftNode.left)</span><br><span class="line">            st.append(rightNode.right)</span><br><span class="line">            st.append(leftNode.right)</span><br><span class="line">            st.append(rightNode.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<br></li>
</ol>
<h1 id="代码随想录-Day23-二叉树最大深度-最小深度"><a href="#代码随想录-Day23-二叉树最大深度-最小深度" class="headerlink" title="代码随想录 - Day23 - 二叉树最大深度&amp;最小深度"></a>代码随想录 - Day23 - 二叉树最大深度&amp;最小深度</h1><h2 id="104-二叉树的最大深度-1"><a href="#104-二叉树的最大深度-1" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><ul>
<li>递归法<ul>
<li>使用前序遍历（找深度）或后序遍历（找高度）</li>
</ul>
</li>
<li>迭代法<ul>
<li>使用层序遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归 前序</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归 后序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.getDepth(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftHeight = self.getDepth(node.left)</span><br><span class="line">        rightHeight = self.getDepth(node.right)</span><br><span class="line">        hight = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight)</span><br><span class="line">        <span class="keyword">return</span> hight</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代 层序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
</li>
</ul>
<h2 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h2><ul>
<li>递归法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depth = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">            depth = <span class="built_in">max</span>(depth, self.maxDepth(child) + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure></li>
<li>迭代法：层序遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> child <span class="keyword">in</span> cur.children:</span><br><span class="line">                    queue.append(child)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="111-二叉树的最小深度-1"><a href="#111-二叉树的最小深度-1" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2><ul>
<li>递归法：左右中<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.getDepth(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftDepth = self.getDepth(node.left)</span><br><span class="line">        rightDepth = self.getDepth(node.right)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要注意根节点只有一侧节点的情况并不是深度为1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth)</span><br></pre></td></tr></table></figure></li>
<li>迭代法：层序遍历，除了根节点，一旦遇到一个没有左节点或右节点的节点，就返回累计的深度<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    <span class="keyword">return</span> cnt</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h1 id="代码随想录-Day24-完全二叉树，平衡二叉树"><a href="#代码随想录-Day24-完全二叉树，平衡二叉树" class="headerlink" title="代码随想录 - Day24 - 完全二叉树，平衡二叉树"></a>代码随想录 - Day24 - 完全二叉树，平衡二叉树</h1><h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h2><ul>
<li>普通二叉树<br>递归<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.getNodeSum(root)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNodeSum</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftNum = self.getNodeSum(cur.left)</span><br><span class="line">        rightNum = self.getNodeSum(cur.right)</span><br><span class="line">        treeNum = leftNum + rightNum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> treeNum</span><br></pre></td></tr></table></figure>
迭代：层序遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">                <span class="built_in">sum</span> += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure></li>
<li>完全二叉树<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = root.left        <span class="comment"># 左树</span></span><br><span class="line">        right = root.right      <span class="comment"># 右树</span></span><br><span class="line">        leftDepth = <span class="number">0</span></span><br><span class="line">        rightDepth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left:             <span class="comment"># 求左数深度</span></span><br><span class="line">            left = left.left</span><br><span class="line">            leftDepth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right:            <span class="comment"># 求右树深度</span></span><br><span class="line">            right = right.right</span><br><span class="line">            rightDepth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> leftDepth == rightDepth:         <span class="comment"># 若左右深度相等则为满二叉树，直接用数学求解</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>     <span class="comment"># 2 &lt;&lt; 1 相当于2^2，所以leftDepth初始为0</span></span><br><span class="line">        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 另一种写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        left = root.left        <span class="comment"># 左树</span></span><br><span class="line">        right = root.right      <span class="comment"># 右树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            left = left.left</span><br><span class="line">            right = right.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:         <span class="comment"># 若左右同时到底则为满二叉树，直接用数学求解</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; count) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<code>2 &lt;&lt; x</code>为<code>2^(x+1)</code><br><code>2 ** x</code>为<code>2^x</code><br>所以后两种写法的<code>count</code>初始值不同<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 另第二种写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        left = root.left        <span class="comment"># 左树</span></span><br><span class="line">        right = root.right      <span class="comment"># 右树</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            left = left.left</span><br><span class="line">            right = right.right</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:         <span class="comment"># 若左右同时到底则为满二叉树，直接用数学求解</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> ** count) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><p>递归：比较高度，后序遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.getHeight(root) != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHeight</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftHeight = self.getHeight(node.left)</span><br><span class="line">        <span class="keyword">if</span> leftHeight == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        rightHeight = self.getHeight(node.right)</span><br><span class="line">        <span class="keyword">if</span> rightHeight == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>:</span><br><span class="line">            result = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>迭代：用栈模拟后序遍历找每一个节点的高度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            st.append(cur)</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                st.pop()</span><br><span class="line">                st.append(node)                           <span class="comment"># 中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">                depth += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    st.append(node.right)                 <span class="comment"># 右</span></span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    st.append(node.left)                   <span class="comment"># 左</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:               </span><br><span class="line">                node = st.pop()</span><br><span class="line">                st.pop()</span><br><span class="line">                depth -= <span class="number">1</span></span><br><span class="line">            result = <span class="built_in">max</span>(result, depth)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()                                 <span class="comment"># 中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(self.getDepth(node.left) - self.getDepth(node.right)) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                st.append(node.right)                       <span class="comment"># 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                st.append(node.left)                         <span class="comment"># 左（空节点不入栈）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>重点掌握递归法，迭代理解即可<br><br></p>
<h1 id="代码随想录-Day25-二叉树的所有路径"><a href="#代码随想录-Day25-二叉树的所有路径" class="headerlink" title="代码随想录 - Day25 - 二叉树的所有路径"></a>代码随想录 - Day25 - 二叉树的所有路径</h1><h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2><p>递归：<br>要传入根节点，记录每一条路径的path，和存放结果集的result，不需要返回值<br>当节点不为空但左右孩子为空时，终止递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        self.traversal(root, path, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur, path, result</span>):</span></span><br><span class="line">        path.append(cur.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">            sPath = <span class="string">&quot;-&gt;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, path))</span><br><span class="line">            result.append(sPath)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cur.left:</span><br><span class="line">            self.traversal(cur.left, path, result)</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> cur.right:</span><br><span class="line">            self.traversal(cur.right, path, result)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>
<p>迭代法：使用前序遍历的迭代方式来模拟遍历路径的过程<br>除了模拟递归需要一个栈，还需要一个栈来存放对应的遍历路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="comment"># 题目中节点数至少为1</span></span><br><span class="line">        stack, path_st, result = [root], [<span class="built_in">str</span>(root.val)], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            path = path_st.pop()</span><br><span class="line">            <span class="comment"># 如果当前节点为叶子节点，添加路径到结果中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (cur.left <span class="keyword">or</span> cur.right):</span><br><span class="line">                result.append(path)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(cur.right.val))</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(cur.left.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<br>

<p><code>map(function, iterable, ...)</code></p>
<ul>
<li><code>function</code> - 针对每一个迭代调用的函数</li>
<li><code>iterable</code> - 支持迭代的一个或者多个对象。在 Python 中大部分内建对象，例如 lists, dictionaries, 和 tuples 都是可迭代的。</li>
</ul>
<p><code>map()</code>返回一个与传入可迭代对象大小一样的 map 对象</p>
<p>简单来说，就是把<code>iterable</code>按顺序依次传入<code>function</code>，并依次返回结果</p>
<h1 id="代码随想录-Day26-左叶子之和，找树左下角的值，路径总和"><a href="#代码随想录-Day26-左叶子之和，找树左下角的值，路径总和" class="headerlink" title="代码随想录 - Day26 - 左叶子之和，找树左下角的值，路径总和"></a>代码随想录 - Day26 - 左叶子之和，找树左下角的值，路径总和</h1><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h2><p>左叶子的明确定义：节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点</p>
<ul>
<li>递归法：后序遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 单层递归逻辑，左右中</span></span><br><span class="line">        leftValue = self.sumOfLeftLeaves(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.left <span class="keyword">and</span> <span class="keyword">not</span> root.left.right:</span><br><span class="line">            leftValue = root.left.val</span><br><span class="line">        rightValue = self.sumOfLeftLeaves(root.right)</span><br><span class="line">        result = leftValue + rightValue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li>
<li>迭代法：前中后序都可以<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        st= []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">                result += node.left.val <span class="comment"># 中</span></span><br><span class="line">            <span class="keyword">if</span> node.right:  <span class="comment"># 右</span></span><br><span class="line">                st.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:   <span class="comment"># 左</span></span><br><span class="line">                st.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h2><p>要找 <strong>最底层 最左边</strong> 的节点的值</p>
<ul>
<li>层序遍历<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                node = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    result = node.val</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li>
<li>递归<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.max_depth = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)  <span class="comment"># 全局变量，记录最大深度</span></span><br><span class="line">        self.result = <span class="literal">None</span>              <span class="comment"># 全局变量，最大深度最左节点的数值</span></span><br><span class="line">        self.traversal(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, node, depth</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:    <span class="comment"># 更新最大深度和最大深度最左节点的数值</span></span><br><span class="line">            <span class="keyword">if</span> depth &gt; self.max_depth:</span><br><span class="line">                self.max_depth = depth</span><br><span class="line">                self.result = node.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            self.traversal(node.left, depth)</span><br><span class="line">            depth -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            self.traversal(node.right, depth)</span><br><span class="line">            depth -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><p>返回<code>True</code>或<code>False</code></p>
<ul>
<li>递归<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur: TreeNode, count: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> count == <span class="number">0</span>: <span class="comment"># 遇到叶子节点，并且计数为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right: <span class="comment"># 遇到叶子节点直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cur.left: <span class="comment"># 左</span></span><br><span class="line">            count -= cur.left.val</span><br><span class="line">            <span class="keyword">if</span> self.traversal(cur.left, count): <span class="comment"># 递归，处理节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            count += cur.left.val <span class="comment"># 回溯，撤销处理结果</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> cur.right: <span class="comment"># 右</span></span><br><span class="line">            count -= cur.right.val</span><br><span class="line">            <span class="keyword">if</span> self.traversal(cur.right, count): <span class="comment"># 递归，处理节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            count += cur.right.val <span class="comment"># 回溯，撤销处理结果</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># sum - root.val 类似回溯的效果</span></span><br><span class="line">        <span class="keyword">return</span> self.traversal(root, <span class="built_in">sum</span> - root.val)      </span><br></pre></td></tr></table></figure></li>
<li>迭代<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 此时栈里要放的是pair&lt;节点指针，路径数值&gt;</span></span><br><span class="line">        stack = [(root, root.val)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, path_sum = stack.pop()</span><br><span class="line">            <span class="comment"># 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> path_sum == <span class="built_in">sum</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, path_sum + node.right.val))</span><br><span class="line">            <span class="comment"># 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, path_sum + node.left.val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><p>返回具体的路径</p>
<ul>
<li>递归<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = []</span><br><span class="line">        self.path = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur, count</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right <span class="keyword">and</span> count == <span class="number">0</span>: <span class="comment"># 遇到了叶子节点且找到了和为sum的路径</span></span><br><span class="line">            self.result.append(self.path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right: <span class="comment"># 遇到叶子节点而没有找到合适的边，直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.left: <span class="comment"># 左 （空节点不遍历）</span></span><br><span class="line">            self.path.append(cur.left.val)</span><br><span class="line">            count -= cur.left.val</span><br><span class="line">            self.traversal(cur.left, count) <span class="comment"># 递归</span></span><br><span class="line">            count += cur.left.val <span class="comment"># 回溯</span></span><br><span class="line">            self.path.pop() <span class="comment"># 回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cur.right: <span class="comment">#  右 （空节点不遍历）</span></span><br><span class="line">            self.path.append(cur.right.val) </span><br><span class="line">            count -= cur.right.val</span><br><span class="line">            self.traversal(cur.right, count) <span class="comment"># 递归</span></span><br><span class="line">            count += cur.right.val <span class="comment"># 回溯</span></span><br><span class="line">            self.path.pop() <span class="comment"># 回溯</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        self.result.clear()        <span class="comment"># clear() 方法从列表中删除所有元素</span></span><br><span class="line">        self.path.clear()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.result</span><br><span class="line">        self.path.append(root.val) <span class="comment"># 把根节点放进路径</span></span><br><span class="line">        self.traversal(root, <span class="built_in">sum</span> - root.val)</span><br><span class="line">        <span class="keyword">return</span> self.result </span><br></pre></td></tr></table></figure></li>
<li>迭代<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [(root, [root.val])]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, path = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="built_in">sum</span>(path) == targetSum:     <span class="comment"># 遇到了叶子节点且找到了和为sum的路径</span></span><br><span class="line">                res.append(path)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, path + [node.right.val]))</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, path + [node.left.val]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<br></li>
</ul>
<h1 id="代码随想录-Day27"><a href="#代码随想录-Day27" class="headerlink" title="代码随想录 - Day27 -"></a>代码随想录 - Day27 -</h1><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 特殊情况讨论: 树为空. 或者说是递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 前序遍历的第一个就是当前的中间节点</span></span><br><span class="line">        rootVal = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找切割点</span></span><br><span class="line">        separator_idx = inorder.index(rootVal)  <span class="comment"># index()用于从列表中找出某个值第一个匹配项的索引位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割inorder数组. 得到inorder数组的左,右半边</span></span><br><span class="line">        inorder_left = inorder[:separator_idx]</span><br><span class="line">        inorder_right = inorder[separator_idx + <span class="number">1</span> :]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割preorder数组. 得到preorder数组的左,右半边</span></span><br><span class="line">        <span class="comment"># 重点: 中序数组大小一定跟前序数组大小是相同的</span></span><br><span class="line">        preorder_left = preorder[<span class="number">1</span> : <span class="number">1</span> + <span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        preorder_right = preorder[<span class="number">1</span> + <span class="built_in">len</span>(inorder_left):]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        root.left = self.buildTree(preorder_left, inorder_left)</span><br><span class="line">        root.right = self.buildTree(preorder_right, inorder_right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>

<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="comment"># 特殊情况讨论: 树为空. 或者说是递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 后序遍历的最后一个就是当前的中间节点</span></span><br><span class="line">        rootVal = postorder[-<span class="number">1</span>]</span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line">        <span class="comment"># 找切割点</span></span><br><span class="line">        separator_idx = inorder.index(rootVal)  <span class="comment"># index()用于从列表中找出某个值第一个匹配项的索引位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割inorder数组. 得到inorder数组的左,右半边</span></span><br><span class="line">        inorder_left = inorder[:separator_idx]</span><br><span class="line">        inorder_right = inorder[separator_idx + <span class="number">1</span> :]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 切割postorderr数组. 得到postorder数组的左,右半边</span></span><br><span class="line">        <span class="comment"># 重点: 中序数组大小一定跟后序数组大小是相同的</span></span><br><span class="line">        postorder_left = postorder[ : <span class="built_in">len</span>(inorder_left)]</span><br><span class="line">        postorder_right = postorder[<span class="built_in">len</span>(inorder_left) : <span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        root.left = self.buildTree(inorder_left, postorder_left)</span><br><span class="line">        root.right = self.buildTree(inorder_right, postorder_right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>
前序和中序可以唯一确定一棵二叉树。

<p>后序和中序可以唯一确定一棵二叉树。</p>
<p>前序和后序不可以唯一确定一棵二叉树！因为没有中序遍历无法确定左右部分，也就是无法分割</p>
<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">        node = TreeNode(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 找数组中最大值及其对应下标</span></span><br><span class="line">        maxVal = <span class="number">0</span></span><br><span class="line">        maxValIdx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; maxVal:</span><br><span class="line">                maxVal = nums[i]</span><br><span class="line">                maxValIdx = i</span><br><span class="line">        node.val = maxVal</span><br><span class="line">        <span class="comment"># 最大值下标左区间</span></span><br><span class="line">        <span class="keyword">if</span> maxValIdx &gt; <span class="number">0</span>:</span><br><span class="line">            newList = nums[:maxValIdx]</span><br><span class="line">            node.left = self.constructMaximumBinaryTree(newList)</span><br><span class="line">        <span class="comment"># 最大值下标右区间</span></span><br><span class="line">        <span class="keyword">if</span> maxValIdx &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">            newList = nums[maxValIdx + <span class="number">1</span>:]</span><br><span class="line">            node.right = self.constructMaximumBinaryTree(newList)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<br>

<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2><p>递归：前中后序都可以</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line"></span><br><span class="line">        root1.val += root2.val                                      <span class="comment"># 中</span></span><br><span class="line">        root1.left = self.mergeTrees(root1.left, root2.left)        <span class="comment"># 左</span></span><br><span class="line">        root1.right = self.mergeTrees(root1.right, root2.right)     <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure>
<p>迭代法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: <span class="type">Optional</span>[TreeNode], root2: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line"></span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append(root1)</span><br><span class="line">        queue.append(root2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue: </span><br><span class="line">            node1 = queue.popleft()</span><br><span class="line">            node2 = queue.popleft()</span><br><span class="line">            <span class="comment"># 更新queue</span></span><br><span class="line">            <span class="comment"># 只有两个节点都有左节点时, 再往queue里面放.</span></span><br><span class="line">            <span class="keyword">if</span> node1.left <span class="keyword">and</span> node2.left: </span><br><span class="line">                queue.append(node1.left)</span><br><span class="line">                queue.append(node2.left)</span><br><span class="line">            <span class="comment"># 只有两个节点都有右节点时, 再往queue里面放.</span></span><br><span class="line">            <span class="keyword">if</span> node1.right <span class="keyword">and</span> node2.right: </span><br><span class="line">                queue.append(node1.right)</span><br><span class="line">                queue.append(node2.right)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新当前节点. 同时改变当前节点的左右孩子. </span></span><br><span class="line">            node1.val += node2.val                  <span class="comment"># 都有就相加</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node1.left <span class="keyword">and</span> node2.left:       <span class="comment"># 只树2有左边</span></span><br><span class="line">                node1.left = node2.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node1.right <span class="keyword">and</span> node2.right:     <span class="comment"># 只树2有右边</span></span><br><span class="line">                node1.right = node2.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure>
<br>


<h1 id="代码随想录-Day28-二叉搜索树"><a href="#代码随想录-Day28-二叉搜索树" class="headerlink" title="代码随想录 - Day28 - 二叉搜索树"></a>代码随想录 - Day28 - 二叉搜索树</h1><h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h2><p>层序遍历，遇到和val相同的节点时，返回该节点即为返回以该节点为根节点的子树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                cur = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> cur.val == val:</span><br><span class="line">                    <span class="keyword">return</span> cur</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br></pre></td></tr></table></figure>
<p>递归法：<br>根据二叉搜索树的特性，<em>左子树所有结点的值都小于根节点，右子树所有节点的值都大于根节点，左右子树也是二叉搜索树</em>，可以得知：<code>root.val &gt; val</code>时只需继续遍历左子树，<code>root.val &lt; val</code>时只需继续遍历右子树</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root.val == val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>迭代法：<br>二叉搜索树的节点是有序的，因此不需要回溯过程，也不需要遍历整棵树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>这样一看，显然一开始第一反应想到的层序遍历并非最合适的解法。层序遍历几乎整棵树消耗了更多时间空间。<br>做题时应当注意特殊的二叉树，比如可以利用二叉搜索树的特性写出更简便的解法。<br><br></p>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><p>*注意不能简单的比较 左节点小于中间节点，右节点大于中间节点，要比较的是 <em>左子树<strong>所有节点</strong>小于中间节点，右子树<strong>所有节点</strong>大于中间节点</em><br>思路1：使用中序遍历，将二叉搜索树转为一个数组，那么这个数组一定是升序的，如果不是，那肯定不是二叉搜索树。<br>思路2：使用中序遍历递归或迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用中序遍历，将二叉搜索树转为一个数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.vec = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(root.left)</span><br><span class="line">        self.vec.append(root.val)   <span class="comment"># 将二叉搜索树转换为有序数组</span></span><br><span class="line">        self.traversal(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.vec = []               <span class="comment"># 清空数组</span></span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(self.vec)):</span><br><span class="line">            <span class="comment"># 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> self.vec[i] &lt;= self.vec[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设定极小值进行比较</span></span><br><span class="line"><span class="comment"># float(&#x27;-inf&#x27;) 表示负无穷</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.maxVal = <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)  <span class="comment"># 因为后台测试数据中有int最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        left = self.isValidBST(root.left)</span><br><span class="line">        <span class="comment"># 中序遍历，验证遍历的元素是不是从小到大</span></span><br><span class="line">        <span class="keyword">if</span> self.maxVal &lt; root.val:</span><br><span class="line">            self.maxVal = root.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        right = self.isValidBST(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">and</span> right</span><br></pre></td></tr></table></figure>
<p>迭代法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        pre = <span class="literal">None</span>                      <span class="comment"># 记录前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left          <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()       <span class="comment"># 中</span></span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">and</span> cur.val &lt;= pre.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                pre = cur               <span class="comment"># 保存前一个访问的节点</span></span><br><span class="line">                cur = cur.right         <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<br>

<h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.vec = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(root.left)</span><br><span class="line">        self.vec.append(root.val)   <span class="comment"># 将二叉搜索树转换为有序数组</span></span><br><span class="line">        self.traversal(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.vec = []               <span class="comment"># 清空数组</span></span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.vec) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)       <span class="comment"># float(&#x27;inf&#x27;) 表示正无穷</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(self.vec)):</span><br><span class="line">            <span class="comment"># 统计有序数组的最小差值</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, self.vec[i] - self.vec[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)  <span class="comment"># float(&#x27;inf&#x27;) 表示正无穷</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.left)</span><br><span class="line">        <span class="keyword">if</span> self.pre:</span><br><span class="line">            self.result = <span class="built_in">min</span>(self.result, cur.val - self.pre.val)</span><br><span class="line">        self.pre = cur              <span class="comment"># 将二叉搜索树转换为有序数组</span></span><br><span class="line">        self.traversal(cur.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure>
<p>迭代法，对上一题的代码稍作修改即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        cur = root</span><br><span class="line">        pre = <span class="literal">None</span>                      <span class="comment"># 记录前一个节点</span></span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left          <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = stack.pop()       <span class="comment"># 中</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    result = <span class="built_in">min</span>(result, cur.val - pre.val)</span><br><span class="line">                pre = cur               <span class="comment"># 保存前一个访问的节点</span></span><br><span class="line">                cur = cur.right         <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<br>

<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h2><p>本题对二叉搜索树的定义做了修改：</p>
<ul>
<li>结点左子树中所含节点的值 小于等于 当前节点的值</li>
<li>结点右子树中所含节点的值 大于等于 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>解题思路分为两个</p>
<ol>
<li>把它当成普通的二叉树来解：遍历整棵树，用map统计频率，再对频率进行排序，取最高频率的为众数。这样做前中后序都可以，只要能全部遍历一遍就行。</li>
<li>按照二叉搜索树来解：二叉搜索树，中序遍历是有序的。遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。</li>
</ol>
<p>递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按普通二叉树</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict  <span class="comment"># leetcode上不导入也可以</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, cur, freq_map</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        freq_map[cur.val] += <span class="number">1</span>       <span class="comment"># 统计元素频率</span></span><br><span class="line">        self.searchBST(cur.left, freq_map)</span><br><span class="line">        self.searchBST(cur.right, freq_map)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        freq_map = defaultdict(<span class="built_in">int</span>)  <span class="comment"># key:元素，value:出现频率</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        self.searchBST(root, freq_map)</span><br><span class="line">        max_freq = <span class="built_in">max</span>(freq_map.values())</span><br><span class="line">        <span class="keyword">for</span> key, freq <span class="keyword">in</span> freq_map.items():</span><br><span class="line">            <span class="keyword">if</span> freq == max_freq:</span><br><span class="line">                result.append(key)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按二叉搜索树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.maxCount = <span class="number">0</span>   <span class="comment"># 最大频率</span></span><br><span class="line">        self.count = <span class="number">0</span>      <span class="comment"># 统计频率</span></span><br><span class="line">        self.pre = <span class="literal">None</span></span><br><span class="line">        self.result = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, cur</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.searchBST(cur.left)    <span class="comment"># 左</span></span><br><span class="line">        <span class="comment"># 中</span></span><br><span class="line">        <span class="keyword">if</span> self.pre <span class="keyword">is</span> <span class="literal">None</span>:        <span class="comment"># 第一个节点</span></span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.pre.val == cur.val:   <span class="comment"># 与前一个节点数值相同</span></span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:                           <span class="comment"># 与前一个节点数值不同</span></span><br><span class="line">            self.count = <span class="number">1</span></span><br><span class="line">        self.pre = cur                  <span class="comment"># 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.count == self.maxCount: <span class="comment"># 如果与最大值频率相同，放进result中</span></span><br><span class="line">            self.result.append(cur.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.count &gt; self.maxCount:  <span class="comment"># 如果计数大于最大值频率</span></span><br><span class="line">            self.maxCount = self.count  <span class="comment"># 更新最大频率</span></span><br><span class="line">            self.result = [cur.val]     <span class="comment"># 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line"></span><br><span class="line">        self.searchBST(cur.right)       <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.maxCount = <span class="number">0</span></span><br><span class="line">        self.pre = <span class="literal">None</span>  <span class="comment"># 记录前一个节点</span></span><br><span class="line">        self.result = []</span><br><span class="line"></span><br><span class="line">        self.searchBST(root)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        st = []</span><br><span class="line">        cur = root</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        maxCount = <span class="number">0</span>    <span class="comment"># 最大频率</span></span><br><span class="line">        count = <span class="number">0</span>       <span class="comment"># 统计频率</span></span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> st:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:     <span class="comment"># 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.append(cur)      <span class="comment"># 将访问的节点放进栈</span></span><br><span class="line">                cur = cur.left      <span class="comment"># 左</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = st.pop()</span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="literal">None</span>:     <span class="comment"># 第一个节点</span></span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> pre.val == cur.val:    <span class="comment"># 与前一个节点数值相同</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:                       <span class="comment"># 与前一个节点数值不同</span></span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> count == maxCount:       <span class="comment"># 如果和最大值相同，放进result中</span></span><br><span class="line">                    result.append(cur.val)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> count &gt; maxCount:        <span class="comment"># 如果计数大于最大值频率</span></span><br><span class="line">                    maxCount = count        <span class="comment"># 更新最大频率</span></span><br><span class="line">                    result = [cur.val]      <span class="comment"># 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line"></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.right             <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<br>


<h1 id="代码随想录-Day29-最近公共祖先，插入操作，删除操作"><a href="#代码随想录-Day29-最近公共祖先，插入操作，删除操作" class="headerlink" title="代码随想录 - Day29 - 最近公共祖先，插入操作，删除操作"></a>代码随想录 - Day29 - 最近公共祖先，插入操作，删除操作</h1><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p>自底向上查找：后序遍历（左右中）+回溯<br>两种情况：</p>
<ol>
<li>p和q分别为某个节点的左右节点，那么这个节点就是它们的最近公共祖先</li>
<li>p(q)为q(p)的子孙节点，那么作为祖先节点的p(q)就是它们的最近公共祖先<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> root == q <span class="keyword">or</span> root == p <span class="keyword">or</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:          <span class="comment"># 若p和q分别为左右节点，返回它们的根节点就可以了</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> right:      <span class="comment"># 只有右节点等于p或q</span></span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:    <span class="comment"># 只有左节点等于p或q</span></span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:                       <span class="comment"># 左右节点都不是p或q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<br></li>
</ol>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h2><ul>
<li>把它当成普通二叉树，找二叉树的最近公共祖先。代码和上一题一样即可，本题就不再给出了。</li>
<li>按照二叉搜索树的特点来找，右节点全部大于根节点，左节点全部小于根节点，那么从上往下搜索时：<ol>
<li>如果pq均小于当前节点，那么继续遍历左子树，如果pq均大于当前节点，那么继续遍历右子树。</li>
<li>如果<code>min(p.val, q.val) &lt;= 当前节点 &lt;= max(p.val, q.val)</code>，那么该节点为二叉搜索树的最近公共祖先<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; <span class="built_in">max</span>(p.val, q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; <span class="built_in">min</span>(p.val, q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span>(p.val, q.val) &lt;= root.val &lt;= <span class="built_in">max</span>(p.val, q.val):</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
注意：如果前面写了<code>if root == q or root == p or not root: return root</code>，那么后面就只需要写<code>&lt;</code>；如果前面写<code>if not root: return root</code>后面才要写<code>&lt;=</code>，要注意对应。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 精简一下，可以写成这样：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; <span class="built_in">max</span>(p.val, q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; <span class="built_in">min</span>(p.val, q.val):</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 或者这样：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br></li>
</ol>
</li>
</ul>
<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h2><p>往简单的方向想。<br>其实不管插入拿个数值，都可以不改变树的结构，直接插入到空节点处。（不理解的话可以自己画图试一试）<br>所以写代码的时候就可以利用二叉搜索树的特点，根据其特点找到合适的空节点处进行插入操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:      <span class="comment"># 待插入数值小于当前节点数值，向左继续搜索</span></span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:      <span class="comment"># 待插入数值大于当前节点数值，向右继续搜索</span></span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root       </span><br></pre></td></tr></table></figure>
<p>不用返回值，找到插入的节点位置后直接让其父节点指向插入节点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur, val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:         <span class="comment"># parent左孩子或者右孩子指向新插入的节点</span></span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">if</span> val &gt; self.parent.val:</span><br><span class="line">                self.parent.right = node</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.parent.left = node</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.parent = cur</span><br><span class="line">        <span class="keyword">if</span> cur.val &gt; val:</span><br><span class="line">            self.traversal(cur.left, val)</span><br><span class="line">        <span class="keyword">if</span> cur.val &lt; val:</span><br><span class="line">            self.traversal(cur.right, val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        self.parent = TreeNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        self.traversal(root, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>迭代法：需要记录一下当前遍历的节点的父节点，这样才能做插入节点的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:    <span class="comment"># 如果根节点为空，创建新节点作为根节点并返回</span></span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        cur = root</span><br><span class="line">        parent = root   <span class="comment"># 记录上一个节点，用于连接新节点</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            parent = cur</span><br><span class="line">            <span class="keyword">if</span> cur.val &gt; val:</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &lt; parent.val:</span><br><span class="line">            parent.left = node  <span class="comment"># 将新节点连接到父节点的左子树</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            parent.right = node <span class="comment"># 将新节点连接到父节点的右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root    </span><br></pre></td></tr></table></figure>
<br>

<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h2><p>删除节点的五种情况：</p>
<ul>
<li>没找到删除的节点：<ul>
<li>遍历到空节点直接返回</li>
</ul>
</li>
<li>找到删除的节点：<ul>
<li>左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回要删除节点的下一个节点就算删除了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root, key</span>):</span></span><br><span class="line">        <span class="comment"># 第一种情况：没找到删除的节点，遍历到空节点直接返回</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val == key:</span><br><span class="line">            <span class="comment"># 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="comment"># 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">elif</span> root.left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="comment"># 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">elif</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment"># 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置, 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = root.right        <span class="comment"># 找右子树最左面的节点</span></span><br><span class="line">                <span class="keyword">while</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = root.left    <span class="comment"># 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
普通二叉树的删除方式：遍历整棵树，用交换值的操作来删除目标节点。<br>代码中目标节点（要删除的节点）被操作了两次：</li>
</ul>
</li>
<li>第一次是和目标节点的右子树最左面节点交换。</li>
<li>第二次直接被NULL覆盖了。</li>
</ul>
<p>不好想，实操性不强</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:            <span class="comment"># 如果根节点为空，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val == key:         <span class="comment"># 找到要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果右子树为空，直接返回左子树作为新的根节点</span></span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            cur = root.right</span><br><span class="line">            <span class="keyword">while</span> cur.left:         <span class="comment"># 找到右子树中的最左节点</span></span><br><span class="line">                cur = cur.left</span><br><span class="line">            root.val, cur.val = cur.val, root.val       <span class="comment"># 将要删除的节点值与最左节点值交换</span></span><br><span class="line">        root.left = self.deleteNode(root.left, key)     <span class="comment"># 在左子树中递归删除目标节点</span></span><br><span class="line">        root.right = self.deleteNode(root.right, key)   <span class="comment"># 在右子树中递归删除目标节点</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>迭代法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteOneNode</span>(<span class="params">self, target: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将目标节点（删除节点）的左子树放到目标节点的右子树的最左面节点的左孩子位置上</span></span><br><span class="line"><span class="string">        并返回目标节点右孩子为新的根节点</span></span><br><span class="line"><span class="string">        是动画里模拟的过程</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">if</span> target.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> target.left</span><br><span class="line">        cur = target.right</span><br><span class="line">        <span class="keyword">while</span> cur.left:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        cur.left = target.left</span><br><span class="line">        <span class="keyword">return</span> target.right</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        cur = root</span><br><span class="line">        pre = <span class="literal">None</span>  <span class="comment"># 记录cur的父节点，用来删除cur</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == key:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pre = cur</span><br><span class="line">            <span class="keyword">if</span> cur.val &gt; key:</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">if</span> pre <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 如果搜索树只有头结点</span></span><br><span class="line">            <span class="keyword">return</span> self.deleteOneNode(cur)</span><br><span class="line">        <span class="comment"># pre 要知道是删左孩子还是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> pre.left <span class="keyword">and</span> pre.left.val == key:</span><br><span class="line">            pre.left = self.deleteOneNode(cur)</span><br><span class="line">        <span class="keyword">if</span> pre.right <span class="keyword">and</span> pre.right.val == key:</span><br><span class="line">            pre.right = self.deleteOneNode(cur)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>
这道题不是很好理解，后续应该多看看多理解理解，掌握第一种递归方法即可。


<h1 id="代码随想录-Day30-修剪二叉树，转换二叉树-二叉树总结"><a href="#代码随想录-Day30-修剪二叉树，转换二叉树-二叉树总结" class="headerlink" title="代码随想录 - Day30 - 修剪二叉树，转换二叉树 + 二叉树总结"></a>代码随想录 - Day30 - 修剪二叉树，转换二叉树 + 二叉树总结</h1><h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><p>有点像是删除二叉搜索树的变形，改变了删除条件而已。<br>递归法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:      <span class="comment"># 当前节点小于low，不用再看其左子树，遍历其右子树即可</span></span><br><span class="line">            right = self.trimBST(root.right, low, high)</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; high:     <span class="comment"># 当前节点大于high，不用再看其右子树，遍历其左子树即可</span></span><br><span class="line">            left = self.trimBST(root.left, low, high)</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        root.left = self.trimBST(root.left, low, high)      <span class="comment"># root.left接入符合条件的左孩子</span></span><br><span class="line">        root.right = self.trimBST(root.right, low, high)    <span class="comment"># root.right接入符合条件的右孩子</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>迭代法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">在剪枝的时候，可以分为三步：</span></span><br><span class="line"><span class="string">将root移动到[L, R] 范围内，注意是左闭右闭区间</span></span><br><span class="line"><span class="string">剪枝左子树</span></span><br><span class="line"><span class="string">剪枝右子树</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 处理头节点，把头结点放到[low, high]范围内</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">and</span> (root.val &lt; low <span class="keyword">or</span> root.val &gt; high):</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; low:      <span class="comment"># 小于low往右走</span></span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:                   <span class="comment"># 大于high往左走</span></span><br><span class="line">                root = root.left</span><br><span class="line">        curleft, curright = root, root</span><br><span class="line">        <span class="comment"># 处理左孩子元素小于low的情况</span></span><br><span class="line">        <span class="keyword">while</span> curleft:</span><br><span class="line">            <span class="keyword">while</span> curleft.left <span class="keyword">and</span> curleft.left.val &lt; low:</span><br><span class="line">                curleft.left = curleft.left.right</span><br><span class="line">            curleft = curleft.left</span><br><span class="line">        <span class="comment"># 处理右孩子元素大于high的情况</span></span><br><span class="line">        <span class="keyword">while</span> curright:</span><br><span class="line">            <span class="keyword">while</span> curright.right <span class="keyword">and</span> curright.right.val &gt; high:</span><br><span class="line">                curright.right = curright.right.left</span><br><span class="line">            curright = curright.right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>

<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><p>对于奇数长度的数组可以直接取中点，对于偶数长度的数组则需要用<code>mid = int(left + ((right - left) / 2))</code>。<br>中点作为根节点，左右两侧则分别为左子树和右子树，依次进行递归遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 左闭右闭区间[left, right]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, nums, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = <span class="built_in">int</span>(left + ((right - left) / <span class="number">2</span>))      <span class="comment"># 防止越界</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.traversal(nums, left, mid - <span class="number">1</span>)</span><br><span class="line">        root.right = self.traversal(nums, mid + <span class="number">1</span>, right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        root = self.traversal(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>迭代法：用队列模拟递归过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root = TreeNode(<span class="number">0</span>)  <span class="comment"># 初始根节点</span></span><br><span class="line">        nodeQue = deque()   <span class="comment"># 放遍历的节点</span></span><br><span class="line">        leftQue = deque()   <span class="comment"># 保存左区间下标</span></span><br><span class="line">        rightQue = deque()  <span class="comment"># 保存右区间下标</span></span><br><span class="line">        </span><br><span class="line">        nodeQue.append(root)               <span class="comment"># 根节点入队列</span></span><br><span class="line">        leftQue.append(<span class="number">0</span>)                  <span class="comment"># 0为左区间下标初始位置</span></span><br><span class="line">        rightQue.append(<span class="built_in">len</span>(nums) - <span class="number">1</span>)     <span class="comment"># len(nums) - 1为右区间下标初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> nodeQue:</span><br><span class="line">            curNode = nodeQue.popleft()</span><br><span class="line">            left = leftQue.popleft()</span><br><span class="line">            right = rightQue.popleft()</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            curNode.val = nums[mid]     <span class="comment"># 将mid对应的元素给中间节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt;= mid - <span class="number">1</span>:         <span class="comment"># 处理左区间</span></span><br><span class="line">                curNode.left = TreeNode(<span class="number">0</span>)</span><br><span class="line">                nodeQue.append(curNode.left)</span><br><span class="line">                leftQue.append(left)</span><br><span class="line">                rightQue.append(mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> right &gt;= mid + <span class="number">1</span>:        <span class="comment"># 处理右区间</span></span><br><span class="line">                curNode.right = TreeNode(<span class="number">0</span>)</span><br><span class="line">                nodeQue.append(curNode.right)</span><br><span class="line">                leftQue.append(mid + <span class="number">1</span>)</span><br><span class="line">                rightQue.append(right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>

<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h2><p>题目中的累加是右中左的顺序进行累加，从最大的节点值累加到最小的节点值。<br>所以要反中序遍历该二叉树，然后顺序累加。<br>需要一个pre指针记录当前节点的前一个节点，这样才能方便累加。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traversal</span>(<span class="params">self, cur</span>):</span>       <span class="comment"># 右中左遍历</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur:                 <span class="comment"># 终止条件</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.traversal(cur.right)   <span class="comment"># 右</span></span><br><span class="line">        cur.val += self.pre         <span class="comment"># 中</span></span><br><span class="line">        self.pre = cur.val</span><br><span class="line">        self.traversal(cur.left)    <span class="comment"># 左</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        self.pre = <span class="number">0</span>                <span class="comment"># 记录前一个节点的数值</span></span><br><span class="line">        self.traversal(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>或者写成这样也可以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>               <span class="comment"># 记录前一个节点的数值</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:                  <span class="comment"># 终止条件</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.convertBST(root.right)   <span class="comment"># 右</span></span><br><span class="line">        root.val += self.pre          <span class="comment"># 中</span></span><br><span class="line">        self.pre = root.val</span><br><span class="line">        self.convertBST(root.left)    <span class="comment"># 左</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>迭代法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root</span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        cur = root</span><br><span class="line">        pre = <span class="number">0</span>         <span class="comment"># 记录前一个节点的数值</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur:                 <span class="comment"># 右</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                cur = stack.pop()   <span class="comment"># 中</span></span><br><span class="line">                cur.val+= pre</span><br><span class="line">                pre = cur.val</span><br><span class="line">                cur =cur.left       <span class="comment"># 左</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<br>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>二叉树这块的题目大部分可以通过递归和迭代两种方式来解决。<br>当遇到二叉搜索树时，可以利用其特性来简化代码。</p>
<p>对不同题目选择合适的遍历方式：</p>
<ul>
<li>涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。</li>
<li>求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。</li>
<li>求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。</li>
</ul>
<p>二叉树的遍历方式（递归和迭代）+层序遍历，必须要掌握。<br>要知道深度优先（前中后序遍历）和广度优先（层序遍历）对应哪些遍历方式。</p>
<p>关键是要掌握解决问题的方法，熟悉代码，理解题目。</p>
<p>二叉树的题就先做到这里，今天再看一下回溯算法的基础，明天开始做题。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>指针问题</title>
    <url>/2024/07/18/%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>做题的时候突然产生的疑问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dumpy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">left, right = dumpy, dumpy</span><br></pre></td></tr></table></figure>

<p>为什么left 和 right 的改变会影响dumpy?</p>
<p><strong>变量和引用</strong></p>
<p>在Python中，所有变量都是对象的引用。当你执行赋值操作时，实际上是将变量名绑定到对象的引用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dumpy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">left, right = dumpy, dumpy</span><br></pre></td></tr></table></figure>

<p><code>dumpy = ListNode(next=head)</code>：这里创建了一个新的 ListNode 对象，并将 dumpy 变量指向这个对象。<br><code>left, right = dumpy, dumpy</code>：这里将 left 和 right 都指向 dumpy 所指向的对象，即刚刚创建的 ListNode 对象。</p>
<p><strong>变量赋值示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出: [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>当 b &#x3D; a 时，b 和 a 都指向同一个列表对象。<br>对 b 进行操作（如 b.append(4)）也会影响 a，因为它们指向的是同一个对象。</p>
<p>同理，在链表操作中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dumpy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">left, right = dumpy, dumpy</span><br></pre></td></tr></table></figure>

<ul>
<li><code>dumpy</code> 是一个新的 <code>ListNode</code> 对象。</li>
<li><code>left</code> 和 <code>right</code> 都指向这个 <code>dumpy</code> 对象。</li>
<li>任何对 <code>left</code> 或 <code>right</code> 的操作（如移动指针）都会反映在它们所指向的链表节点上。</li>
</ul>
<p><code>left</code> 和 <code>right</code> 都是指向 <code>dumpy</code> 链表中的节点的指针，当我们移动它们时，它们所指向的节点在链表中的位置发生了改变。因此，当我们修改 <code>left.next</code> 的时候，这实际上是在修改 <code>dumpy</code> 链表的结构。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>指针</tag>
      </tags>
  </entry>
</search>
